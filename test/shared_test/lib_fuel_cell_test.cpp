#include "lib_fuel_cell_test.h"

TEST_F(FuelCellTest, EfficiencyCurve)
{
	fuelCell->calculateEfficiencyCurve(.16);
	EXPECT_EQ(fuelCell->getElectricalEfficiency(), 0.21);
	EXPECT_EQ(fuelCell->getHeatRecoveryEfficiency(), .50);
}

TEST_F(FuelCellTest, Initialize)
{
	// Test if started up
	EXPECT_EQ(fuelCell->isRunning(), false);
}

TEST_F(FuelCellTest, Startup)
{
	// Run for startup_hours - 1
	for (size_t h = 0; h < startup_hours - 1; h++) {
		fuelCell->runSingleTimeStep(20);
		EXPECT_EQ(fuelCell->getPower(), 0);
		EXPECT_FALSE(fuelCell->isRunning());
	}

	// After one more hour it will be started, but won't deliver power during that time step
	fuelCell->runSingleTimeStep(20);
	EXPECT_EQ(fuelCell->getPower(), 0);
	EXPECT_TRUE(fuelCell->isRunning());

	// Next hour, it's fully started up
	fuelCell->runSingleTimeStep(20);
	EXPECT_EQ(fuelCell->getPower(), 20);

	// Test Min Turndown
	fuelCell->runSingleTimeStep(unitPowerMin_kW - 10);
	EXPECT_EQ(fuelCell->getPower(), unitPowerMin_kW);

	// Test ramp up limit
	fuelCell->runSingleTimeStep(100);
	EXPECT_EQ(fuelCell->getPower(), unitPowerMin_kW + dynamicResponseUp_kWperHour);
	fuelCell->runSingleTimeStep(100);
	fuelCell->runSingleTimeStep(100);
	fuelCell->runSingleTimeStep(100);
	fuelCell->runSingleTimeStep(100);

	// Test Max Limit (is not unitPowerMax_kW due to degradation)
	fuelCell->runSingleTimeStep(unitPowerMax_kW + 10);
	EXPECT_EQ(fuelCell->getPower(), fuelCell->getMaxPower());

	// Test ramp down limit
	fuelCell->runSingleTimeStep(0);
	EXPECT_NEAR(fuelCell->getPower(), fuelCell->getMaxPower() - dynamicResponseDown_kWperHour, 0.1);
}


TEST_F(FuelCellTest, Shutdown)
{
	fuelCell->setShutdownOption(FuelCell::FC_SHUTDOWN_OPTION::SHUTDOWN);

	// Run for startup_hours
	for (size_t h = 0; h < (size_t)startup_hours; h++) {
		fuelCell->runSingleTimeStep(20);
	}

	// Run for a few hours started up
	for (size_t h = (size_t)startup_hours; h < (size_t)(startup_hours + 5); h++) {
		fuelCell->runSingleTimeStep(20);
		EXPECT_TRUE(fuelCell->isRunning());
	}

	// Initiate shutdown.  Should produce heat but no electricity for shutdown hours
	for (size_t h = 0; h < (size_t)shutdown_hours; h++) {
		fuelCell->runSingleTimeStep(0);
		EXPECT_EQ(fuelCell->getPower(), 0);
		EXPECT_GT(fuelCell->getPowerThermal(), 0);
		EXPECT_FALSE(fuelCell->isRunning());
	}

	// After one more hour it will be fully shut down
	fuelCell->runSingleTimeStep(0);
	EXPECT_EQ(fuelCell->getPower(), 0);
	EXPECT_EQ(fuelCell->getPowerThermal(), 0);
	EXPECT_FALSE(fuelCell->isRunning());

}

TEST_F(FuelCellTest, AvailableFuel) {

	
	// Run for startup_hours, assume no fuel consumed from available stock during startup
	for (size_t h = 0; h < (size_t)startup_hours; h++) {
		fuelCell->runSingleTimeStep(20);
		EXPECT_EQ(fuelCell->getAvailableFuel(), availableFuel_Mcf);
	}

	// Available fuel should start decreasing
	double availableFuelTrack = availableFuel_Mcf;
	for (size_t h = (size_t)startup_hours; h < (size_t)startup_hours + 10; h++) {
		fuelCell->runSingleTimeStep(20);
		EXPECT_EQ(fuelCell->getAvailableFuel(), availableFuelTrack - fuelCell->getFuelConsumption());
		availableFuelTrack -= fuelCell->getFuelConsumption();
	}

}

// Calculate the heat being generated by the fuel cell
TEST_F(FuelCellTest, HeatCalculation) {

	// Run for startup_hours, assume no available heat
	for (size_t h = 0; h < (size_t)startup_hours; h++) {
		fuelCell->runSingleTimeStep(20);
		EXPECT_EQ(fuelCell->getPowerThermal(), 0);
	}

	// Heat should start be generated
	for (size_t h = (size_t)startup_hours; h < (size_t)startup_hours + 10; h++) {
		fuelCell->runSingleTimeStep(20);
		EXPECT_EQ(fuelCell->getPowerThermal(), 20 * fuelCell->getHeatRecoveryEfficiency());
	}

}

// Verify that replacements are being handled
TEST_F(FuelCellTest, Replacements) {

	fuelCell->setStartupHours(1);
	fuelCell->setDegradationkWPerHour(40);
	fuelCell->setReplacementOption(FuelCell::FC_REPLACEMENT_OPTION::REPLACE_AT_CAPACITY);
	fuelCell->setReplacementCapacity(50);

	// Run for two hours, should hit replacement
	for (size_t h = 0; h < (size_t)3; h++) {
		fuelCell->runSingleTimeStep(20);
	}

	EXPECT_EQ(fuelCell->getTotalReplacements(), 1);
}

// Verify that scheduled restarts are being handled
TEST_F(FuelCellTest, ScheduleRestarts) {

	util::matrix_t<size_t> shutdowns;
	shutdowns.resize_fill(1, 2, 4);

	fuelCell->setStartupHours(1);
	fuelCell->setDegradationkWPerHour(0);
	fuelCell->setDegradationRestartkW(1);
	fuelCell->setScheduledShutdowns(shutdowns);

	// Run for 4 hours (1 to startup)
	for (size_t h = 0; h < (size_t)4; h++) {
		fuelCell->runSingleTimeStep(20);
	}
	// Next 4 hours should be shutdown by schedule, but takes 8 hours to shutdown
	for (size_t h = 0; h < (size_t)shutdown_hours; h++) {
		fuelCell->runSingleTimeStep(20);
		EXPECT_EQ(fuelCell->getPower(), 0);
	}
	// Ensure restart degradation applied
	EXPECT_EQ(fuelCell->getMaxPower(), fuelCell->getMaxPowerOriginal() - 1.0);

	// Run for startup hours
	for (size_t h = 0; h < (size_t)1; h++) {
		fuelCell->runSingleTimeStep(20);
		EXPECT_EQ(fuelCell->getPower(), 0);
	}
	// Next hours should be running
	for (size_t h = 0; h < (size_t)4; h++) {
		fuelCell->runSingleTimeStep(20);
		EXPECT_GT(fuelCell->getPower(), 0);
	}
}


// Also check multiple fuel cells
TEST_F(FuelCellTest, DispatchFixed) {

	size_t sh = (size_t)startup_hours;

	// Allow fuel cell to startup
	for (size_t h = 0; h < sh; h++) {
		fuelCellDispatchMultiple->runSingleTimeStep(h, h, 0, 0);
		EXPECT_EQ(fuelCell->getPower(), 0);
	}

	// Unit will take two hours to fully ramp to 40 kW
	fuelCellDispatchMultiple->runSingleTimeStep(sh, 0, 0);
	EXPECT_EQ(fuelCell->getPower(), 20);

	// Run at fixed output, which will go lower than min turndown
	for (size_t h = sh + 1; h < sh + 10; h++) {
		fuelCellDispatchMultiple->runSingleTimeStep(h, h, 20,10);
		EXPECT_EQ(fuelCell->getPower(), unitPowerMax_kW * fixed_percent * 0.01);
		EXPECT_EQ(fuelCellDispatchMultiple->getBatteryPower()->powerFuelCellToLoad, 0);
		EXPECT_EQ(fuelCellDispatchMultiple->getBatteryPower()->powerFuelCellToGrid, n_multipleFuelCells * 40);
		EXPECT_EQ(fuelCellDispatchMultiple->getBatteryPower()->powerPVToLoad,  10);
		EXPECT_EQ(fuelCellDispatchMultiple->getBatteryPower()->powerPVToGrid,  10);
	}
}

TEST_F(FuelCellTest, DispatchLoadFollow) {

	size_t sh = (size_t)startup_hours;

	fuelCellDispatch->setDispatchOption(FuelCellDispatch::FC_DISPATCH_OPTION::LOAD_FOLLOW);

	// Allow fuel cell to startup
	for (size_t h = 0; h < sh; h++) {
		fuelCellDispatch->runSingleTimeStep(h, h, 0, 20);
		EXPECT_EQ(fuelCell->getPower(), 0);
	}

	// Dispatch fuel cell for net load of 20 kW
	fuelCellDispatch->runSingleTimeStep(sh, sh, 20, 40);
	EXPECT_EQ(fuelCell->getPower(), 20);

	// Dispatch fuel cell for net load of 60 kW, dynamic response should limit to 40 kW
	fuelCellDispatch->runSingleTimeStep(sh + 1, sh + 1, 20, 80);
	EXPECT_EQ(fuelCell->getPower(), 40);

	// Dispatch fuel cell for net load of 60 kW, should be fully ramped by now
	fuelCellDispatch->runSingleTimeStep(sh + 2, sh + 2, 20, 80);
	EXPECT_EQ(fuelCell->getPower(), 60);
}

TEST_F(FuelCellTest, DispatchManual) {

	size_t sh = (size_t)startup_hours;
	size_t stepsPerHour = (size_t)(1 / dt_subHourly);

	fuelCellDispatchSubhourly->setDispatchOption(FuelCellDispatch::FC_DISPATCH_OPTION::MANUAL);

	// Allow fuel cell to startup
	size_t year_idx = 0;
	for (size_t h = 0; h < sh; h++) {
		for (size_t s = 0; s < stepsPerHour; s++) {
			fuelCellDispatchSubhourly->runSingleTimeStep(h, year_idx, 0, 20);
			year_idx++;
		}
		EXPECT_EQ(fuelCellSubHourly->getPower(), 0);
	}

	// Dispatch fuel cell at 40% of max output (40 kW, limited by dynamic response, and min turndown)
	for (size_t s = 0; s < stepsPerHour; s++) {
		fuelCellDispatchSubhourly->runSingleTimeStep(sh, year_idx, 20, 40);
		year_idx++;
	}
	EXPECT_EQ(fuelCellSubHourly->getPower(), 35);

	// Dispatch fuel cell at 40% of max output (40 kW)
	for (size_t s = 0; s < stepsPerHour; s++) {
		fuelCellDispatchSubhourly->runSingleTimeStep(sh + 1, year_idx, 20, 80);
		EXPECT_EQ(fuelCellSubHourly->getPower(), 40);
		year_idx++;
	}
}

TEST_F(FuelCellTest, DispatchInput) {

	size_t sh = (size_t)startup_hours;

	// Dispatch input is set to constant 50 kW
	fuelCellDispatch->setDispatchOption(FuelCellDispatch::FC_DISPATCH_OPTION::INPUT);

	// Allow fuel cell to startup
	for (size_t h = 0; h < sh; h++) {
		fuelCellDispatch->runSingleTimeStep(h, h, 0, 20);
		EXPECT_EQ(fuelCell->getPower(), 0);
	}

	// Dispatch fuel cell at 50% of max output (50 kW, limited by dynamic response)
	fuelCellDispatch->runSingleTimeStep(sh, sh, 0, 0);
	EXPECT_EQ(fuelCell->getPower(), 20);

	// Dispatch fuel cell at 50% of max output (50 kW, limited by dynamic response)
	fuelCellDispatch->runSingleTimeStep(sh + 1, sh + 1, 0, 0);
	EXPECT_EQ(fuelCell->getPower(), 40);

	// Dispatch fuel cell at 50% of max output (50 kW)
	for (size_t h = sh + 2; h < 50; h++) {
		fuelCellDispatch->runSingleTimeStep(h, h, 0, 0);
		EXPECT_EQ(fuelCell->getPower(), 50);
	}
}