//File automatically generated by variable_map_makefile.py 2023/6/9


/*
BSD 3-Clause License

Copyright (c) Alliance for Sustainable Energy, LLC. See also https://github.com/NREL/ssc/blob/develop/LICENSE
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#include "definitions.h"
#include "mod_base.h"
#include "string_util.h"

var_map::var_map()
{
    reset();
}

var_map::var_map( var_map &vc )
{
    reset();
    copy( vc );
}

void var_map::copy( var_map &vc )
{
    //to copy, we need to make sure the template structures for heliostats and receivers are
    //parallel between both varmaps first. Then copy by iterating over the list of strings in
    //the varmap and set the corresponding object values in each map.

    //receiver templates
    for( size_t i=0; i<recs.size(); i++ )
        drop_receiver((int)i);
    for( size_t i=0; i<vc.recs.size(); i++ )
        add_receiver( vc.recs.at(i).id.val );

    //heliostat templates
    for( size_t i=0; i<hels.size(); i++ )
        drop_heliostat((int)i);
    for( size_t i=0; i<vc.hels.size(); i++ )
        add_heliostat( vc.hels.at(i).id.val );

    //now add by string->obj
    for( unordered_map< std::string, spbase* >::iterator var=_varptrs.begin(); var!=_varptrs.end(); var++ )
        var->second->set_from_string( vc._varptrs.at( var->first )->as_string().c_str() );
    
    return;
}

void var_map::reset()
{
    //first clear the receiver and heliostat objects
    hels.clear();
    recs.clear();
    //clear out pointer map
    _varptrs.clear();
    
    //reserve size for the templates. otherwise, the pointer addresses get confused. This is the max limit of templates.
    hels.reserve(100);
    recs.reserve(100);
    
	amb.atm_coefs                    .set("ambient.0.atm_coefs"              , SP_DATTYPE::SP_MATRIX_T  , "0.006789,0.1046,-0.0170,0.002845;0.01293,0.2748,-.03394,0;0.006789,0.1046,-0.0170,0.002845",       "none",    false,         "", "0.006789,0.1046,-0.0170,0.002845;0.01293,0.2748,-.03394,0;0.006789,0.1046,-0.0170,0.002845",    false,               "User-defined attenuation", "Atmospheric attenuation coefficients for user-defined analysis");
	amb.atm_model                    .set("ambient.0.atm_model"              , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "DELSOL3 clear day=0;DELSOL3 hazy day=1;User-defined=2",    false,          "Atmospheric attenuation model", "Atmospheric attenuation model {0=25km Barstow, 1 = 5km Barstow, 2 = user defined}");
	amb.class_name                   .set("ambient.0.class_name"             , SP_DATTYPE::SP_STRING    ,            "Climate",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	amb.del_h2o                      .set("ambient.0.del_h2o"                , SP_DATTYPE::SP_DOUBLE    ,               "20.0",     "mm H2O",    false,         "",    "",    false,         "Atmospheric precipitable water", "Atmospheric precipitable water depth for use in the Allen insolation model");
	amb.dni_layout                   .set("ambient.0.dni_layout"             , SP_DATTYPE::SP_DOUBLE    ,              "950.0",       "W/m2",     true,         "",    "",    false,   "Constant DNI for layout calculations", "DNI to use during all layout calculations. CONSTANT model only.");
	amb.dpres                        .set("ambient.0.dpres"                  , SP_DATTYPE::SP_DOUBLE    ,                "1.0",        "atm",     true,         "",    "",    false,                       "Ambient pressure", "Local ambient pressure relative to sea-level pressure");
	amb.elevation                    .set("ambient.0.elevation"              , SP_DATTYPE::SP_DOUBLE    ,              "588.0",          "m",    false,         "",    "",    false,                        "Plant elevation", "Plant mean elevation");
	amb.insol_type                   .set("ambient.0.insol_type"             , SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "Weather file data=-1;Meinel model=0;Hottel model=1;Constant value=2;Allen model=3;Moon model=4",    false,                       "Insolation model", "Model used to determine insolation as a function of time");
	amb.latitude                     .set("ambient.0.latitude"               , SP_DATTYPE::SP_DOUBLE    ,             "34.867",        "deg",    false,         "",    "",    false,                         "Plant latitude", "Plant latitude");
	amb.loc_city                     .set("ambient.0.loc_city"               , SP_DATTYPE::SP_STRING    ,          "city name",       "none",    false,         "",    "",    false,             "Weather file location name", "City or place name for weather station (informational only)");
	amb.loc_state                    .set("ambient.0.loc_state"              , SP_DATTYPE::SP_STRING    ,         "state name",       "none",    false,         "",    "",    false,                "Weather file state name", "State name for weather station (informational only)");
	amb.longitude                    .set("ambient.0.longitude"              , SP_DATTYPE::SP_DOUBLE    ,           "-116.783",        "deg",    false,         "",    "",    false,                        "Plant longitude", "Plant longitude");
	amb.sun_csr                      .set("ambient.0.sun_csr"                , SP_DATTYPE::SP_DOUBLE    ,                "0.1",       "none",     true,         "",    "",    false,                      "Circumsolar ratio", "Ratio of solar flux contained in the circumsolar ring over the solar disc flux");
	amb.sun_pos_map                  .set("ambient.0.sun_pos_map"            , SP_DATTYPE::SP_MATRIX_T  ,                   "",  "[deg,deg]",    false,         "",    "",    false,                            "sun_pos_map", "Map of sun positions to use for calculations");
	amb.sun_rad_limit                .set("ambient.0.sun_rad_limit"          , SP_DATTYPE::SP_DOUBLE    ,               "4.65",       "mrad",     true,         "",    "",    false,                "Sunshape angular extent", "Half-angle of sunshape size (4.65mrad for Pillbox, 2.73mrad for Gaussian)");
	amb.sun_type                     .set("ambient.0.sun_type"               , SP_DATTYPE::SP_STRING    ,                  "2",       "none",     true,    "combo", "Pillbox sun=2;Gaussian sun=4;Limb-darkened sun=1;Point sun=0;Buie CSR=5;User sun=3;",    false,                         "Sunshape model", "Sunshape model - {0=point sun, 1=limb darkened sun, 2=square wave sun, 3=user sun}");
	amb.time_zone                    .set("ambient.0.time_zone"              , SP_DATTYPE::SP_DOUBLE    ,               "-8.0",         "hr",    false,         "",    "",    false,                              "Time zone", "Time zone");
	amb.user_sun                     .set("ambient.0.user_sun"               , SP_DATTYPE::SP_MATRIX_T  ,                   "",  "[deg,deg]",    false,         "",    "",    false,                               "user_sun", "Array of intensity at various angles from the centroid of the sun");
	amb.weather_file                 .set("ambient.0.weather_file"           , SP_DATTYPE::SP_STRING    , "USA CA Daggett (TMY2).csv",       "none",     true,         "",    "",    false,                           "Weather file", "Weather file to use for analysis");
	amb.wf_data                      .set("ambient.0.wf_data"                , SP_DATTYPE::SP_WEATHERDATA,                   "",       "none",    false,         "",    "",    false,                                "wf_data", "Data entries in the weather file");
	amb.atm_atten_est                .setup("ambient.0.atm_atten_est"          , SP_DATTYPE::SP_DOUBLE    ,                                "%",    false,         "",    "",    false,                    "Average attenuation", "Average solar field attenuation due to atmospheric scattering");
	amb.sim_time_step                .setup("ambient.0.sim_time_step"          , SP_DATTYPE::SP_DOUBLE    ,                              "sec",    false,         "",    "",    false,      "Simulation weather data time step", "Simulation weather data time step");
	amb.sun_csr_adj                  .setup("ambient.0.sun_csr_adj"            , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,            "Corrected circumsolar ratio", "Correction of circumsolar ratio based on energy balance");

	fin.class_name                   .set("financial.0.class_name"           , SP_DATTYPE::SP_STRING    ,          "Financial",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	fin.contingency_rate             .set("financial.0.contingency_rate"     , SP_DATTYPE::SP_DOUBLE    ,                "7.0",          "%",     true,         "",    "",    false,                            "Contingency", "Fraction of the direct capital costs added to account for contingency");
	fin.fixed_cost                   .set("financial.0.fixed_cost"           , SP_DATTYPE::SP_DOUBLE    ,                "0.0",          "$",    false,         "",    "",    false,                             "Fixed cost", "Cost that does not scale with any plant parameter");
	fin.heliostat_spec_cost          .set("financial.0.heliostat_spec_cost"  , SP_DATTYPE::SP_DOUBLE    ,              "145.0",       "$/m2",     true,         "",    "",    false,                        "Heliostat field", "Cost per square meter of heliostat aperture area of the heliostat field");
	fin.is_pmt_factors               .set("financial.0.is_pmt_factors"       , SP_DATTYPE::SP_BOOL      ,              "False",           "",    false, "checkbox",    "",    false,       "Enable payment weighting factors", "Enable or disable the use of weighting factors in determining field layout");
	fin.land_spec_cost               .set("financial.0.land_spec_cost"       , SP_DATTYPE::SP_DOUBLE    ,            "10000.0",     "$/acre",     true,         "",    "",    false,                     "Land cost per acre", "Cost of land per acre including the footprint of the land occupied by the entire plant.");
	fin.pmt_factors                  .set("financial.0.pmt_factors"          , SP_DATTYPE::SP_VEC_DOUBLE, "2.064,1.2,1,1.1,0.8,0.7,1,1,1",       "none",    false,         "",    "",    false,             "Payment allocation factors", "Relative value of electricity produced during this period compared to the average");
	fin.rec_cost_exp                 .set("financial.0.rec_cost_exp"         , SP_DATTYPE::SP_DOUBLE    ,                "0.7",       "none",     true,         "",    "",    false,         "Receiver cost scaling exponent", "Exponent in the equation (total cost) = (ref. cost) * ( (area) / (ref. area) ) ^ X");
	fin.rec_ref_area                 .set("financial.0.rec_ref_area"         , SP_DATTYPE::SP_DOUBLE    ,             "1571.0",         "m2",     true,         "",    "",    false,                "Receiver reference area", "Receiver surface area corresponding to the receiver reference cost");
	fin.rec_ref_cost                 .set("financial.0.rec_ref_cost"         , SP_DATTYPE::SP_DOUBLE    ,        "103000000.0",          "$",     true,         "",    "",    false,                "Receiver reference cost", "Cost of the receiver at the sizing indicated by the reference receiver area");
	fin.sales_tax_frac               .set("financial.0.sales_tax_frac"       , SP_DATTYPE::SP_DOUBLE    ,               "80.0",          "%",     true,         "",    "",    false,                 "Sales tax rate portion", "Fraction of the direct capital costs for which sales tax applies");
	fin.sales_tax_rate               .set("financial.0.sales_tax_rate"       , SP_DATTYPE::SP_DOUBLE    ,                "5.0",          "%",     true,         "",    "",    false,                         "Sales tax rate", "Sales tax rate applid to the total direct capital cost");
	fin.site_spec_cost               .set("financial.0.site_spec_cost"       , SP_DATTYPE::SP_DOUBLE    ,               "16.0",       "$/m2",     true,         "",    "",    false,                      "Site improvements", "Cost per square meter of heliostat aperture area of site improvements");
	fin.tower_exp                    .set("financial.0.tower_exp"            , SP_DATTYPE::SP_DOUBLE    ,             "0.0113",       "none",     true,         "",    "",    false,            "Tower cost scaling exponent", "Exponent in the equation (total cost) = (fixed cost) * exp( X * (tower height) )");
	fin.tower_fixed_cost             .set("financial.0.tower_fixed_cost"     , SP_DATTYPE::SP_DOUBLE    ,          "3000000.0",          "$",     true,         "",    "",    false,                       "Fixed tower cost", "Fixed tower cost - used as the basis for scaling tower cost as a function of height");
	fin.weekday_sched                .set("financial.0.weekday_sched"        , SP_DATTYPE::SP_STRING    , "666666554444444444444555666666554444444444444555666666554444444444444555666666554444444444444555666666554444444444444555333333332222111111222333333333332222111111222333333333332222111111222333333333332222111111222333666666554444444444444555666666554444444444444555666666554444444444444555",           "",    false,         "",    "",    false,       "Weekday dispatch period schedule", "Weekday dispatch period schedule");
	fin.weekend_sched                .set("financial.0.weekend_sched"        , SP_DATTYPE::SP_STRING    , "666666555555555555555555666666555555555555555555666666555555555555555555666666555555555555555555666666555555555555555555333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333666666555555555555555555666666555555555555555555666666555555555555555555",           "",    false,         "",    "",    false,       "Weekend dispatch period schedule", "Weekend dispatch period schedule");
	fin.wiring_user_spec             .set("financial.0.wiring_user_spec"     , SP_DATTYPE::SP_DOUBLE    ,                "0.0",       "$/m2",     true,         "",    "",    false,                   "Wiring specific cost", "Cost of wiring per square meter of heliostat aperture area");
	fin.contingency_cost             .setup("financial.0.contingency_cost"     , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                       "Contingency cost", "Contingency cost");
	fin.heliostat_cost               .setup("financial.0.heliostat_cost"       , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                   "Heliostat field cost", "Heliostat field cost");
	fin.land_cost                    .setup("financial.0.land_cost"            , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                              "Land cost", "Land cost");
	fin.pricing_array                .setup("financial.0.pricing_array"        , SP_DATTYPE::SP_VEC_DOUBLE,                             "none",    false,         "",    "",    false, "Time series schedule of price multipliers", "Yearly time series schedule of price multipliers to incentivize electricity sales at particular times");
	fin.rec_cost                     .setup("financial.0.rec_cost"             , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                          "Receiver cost", "Receiver cost");
	fin.sales_tax_cost               .setup("financial.0.sales_tax_cost"       , SP_DATTYPE::SP_DOUBLE    ,                                "$",     true,         "",    "",    false,                         "Sales tax cost", "Sales tax cost");
	fin.schedule_array               .setup("financial.0.schedule_array"       , SP_DATTYPE::SP_VEC_INTEGER,                             "none",    false,         "",    "",    false,    "Time series schedule of TOU periods", "Yearly time series schedule of TOU periods");
	fin.site_cost                    .setup("financial.0.site_cost"            , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                 "Site improvements cost", "Site improvements cost");
	fin.total_direct_cost            .setup("financial.0.total_direct_cost"    , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                      "Total direct cost", "Sum of all direct costs");
	fin.total_indirect_cost          .setup("financial.0.total_indirect_cost"  , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                    "Total indirect cost", "Sum of all indirect costs");
	fin.total_installed_cost         .setup("financial.0.total_installed_cost" , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                   "Total installed cost", "Sum of direct and indirect costs");
	fin.tower_cost                   .setup("financial.0.tower_cost"           , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                             "Tower cost", "Tower cost");
	fin.wiring_cost                  .setup("financial.0.wiring_cost"          , SP_DATTYPE::SP_DOUBLE    ,                                "$",    false,         "",    "",    false,                            "Wiring cost", "Wiring cost");

	flux.aim_method                  .set("fluxsim.0.aim_method"             , SP_DATTYPE::SP_STRING    ,                  "3",           "",     true,    "combo", "Simple aim points=0;Sigma aiming=1;Probability shift=2;Image size priority=3;Keep existing=4;Freeze tracking=5",    false,             "Heliostat aim point method", "Method for determining the aim point for each heliostat");
	flux.class_name                  .set("fluxsim.0.class_name"             , SP_DATTYPE::SP_STRING    , "Performance Simulation",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	flux.cloud_depth                 .set("fluxsim.0.cloud_depth"            , SP_DATTYPE::SP_DOUBLE    ,              "250.0",          "m",     true,         "",    "",    false,                            "Cloud depth", "Depth of the cloud shape");
	flux.cloud_loc_x                 .set("fluxsim.0.cloud_loc_x"            , SP_DATTYPE::SP_DOUBLE    ,              "200.0",          "m",     true,         "",    "",    false,                     "Cloud location (X)", "Base location of the cloud(s) relative to the tower position - X dimension");
	flux.cloud_loc_y                 .set("fluxsim.0.cloud_loc_y"            , SP_DATTYPE::SP_DOUBLE    ,              "200.0",          "m",     true,         "",    "",    false,                     "Cloud location (Y)", "Base location of the cloud(s) relative to the tower position - Y dimension");
	flux.cloud_opacity               .set("fluxsim.0.cloud_opacity"          , SP_DATTYPE::SP_DOUBLE    ,                "0.8",       "none",     true,         "",    "",    false,                          "Cloud opacity", "Fraction of DNI obfuscated by a cloud shadow");
	flux.cloud_sep_depth             .set("fluxsim.0.cloud_sep_depth"        , SP_DATTYPE::SP_DOUBLE    ,                "1.0",           "",     true,         "",    "",    false,      "Cloud pattern depth spacing mult.", "Cloud pattern depth spacing");
	flux.cloud_sep_width             .set("fluxsim.0.cloud_sep_width"        , SP_DATTYPE::SP_DOUBLE    ,                "2.0",           "",     true,         "",    "",    false,      "Cloud pattern width spacing mult.", "Cloud pattern width spacing");
	flux.cloud_shape                 .set("fluxsim.0.cloud_shape"            , SP_DATTYPE::SP_STRING    ,                  "0",           "",     true,    "combo", "Elliptical=0;Rectangular=1;Front=2",    false,                            "Cloud shape", "Shape used to model the cloud shadow");
	flux.cloud_skew                  .set("fluxsim.0.cloud_skew"             , SP_DATTYPE::SP_DOUBLE    ,               "35.0",        "deg",     true,         "",    "",    false,                "Cloud orientation angle", "Angle between North and the depth direction (-180 to +180 with clockwise positive)");
	flux.cloud_width                 .set("fluxsim.0.cloud_width"            , SP_DATTYPE::SP_DOUBLE    ,              "500.0",          "m",     true,         "",    "",    false,                            "Cloud width", "Width of the cloud shape");
	flux.flux_data                   .set("fluxsim.0.flux_data"              , SP_DATTYPE::SP_STRING    ,                   "",           "",    false,         "",    "",    false,            "Flux profile in string form", "2D matrix of flux data");
	flux.flux_day                    .set("fluxsim.0.flux_day"               , SP_DATTYPE::SP_INT       ,                 "20",           "",     true,         "",    "",    false,                       "Day of the month", "Day of the month for the flux simulation");
	flux.flux_dist                   .set("fluxsim.0.flux_dist"              , SP_DATTYPE::SP_STRING    ,                  "0",           "",     true,    "combo", "Triangular=0;Normal=1;Uniform=2",    false,        "Aim point distribution sampling", "Sampling basis for random positioning. Non-uniform distributions are weighted away from the center.");
	flux.flux_dni                    .set("fluxsim.0.flux_dni"               , SP_DATTYPE::SP_DOUBLE    ,              "950.0",       "W/m2",     true,         "",    "",    false,              "Direct Normal Irradiation", "Direct Normal Irradiation at the specified simulation point");
	flux.flux_hour                   .set("fluxsim.0.flux_hour"              , SP_DATTYPE::SP_DOUBLE    ,               "12.0",         "hr",     true,         "",    "",    false,                        "Hour of the day", "Hour of the day for the flux simulation");
	flux.flux_model                  .set("fluxsim.0.flux_model"             , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "Hermite (analytical)=0;SolTrace=1",    false,                  "Flux simulation model", "Desired flux simulation tool. Not all geometries can be simulated using the Hermite approximation.");
	flux.flux_month                  .set("fluxsim.0.flux_month"             , SP_DATTYPE::SP_INT       ,                  "3",           "",     true,         "",    "",    false,                      "Month of the year", "Month of the year for the flux simulation");
	flux.flux_solar_az_in            .set("fluxsim.0.flux_solar_az_in"       , SP_DATTYPE::SP_DOUBLE    ,              "180.0",           "",     true,         "",    "",    false,              "Solar azimuth angle (0=N)", "Solar azimuth angle to use for the flux simulation");
	flux.flux_solar_el_in            .set("fluxsim.0.flux_solar_el_in"       , SP_DATTYPE::SP_DOUBLE    ,               "85.0",           "",     true,         "",    "",    false,                  "Solar elevation angle", "Solar elevation angle to use for the flux simulation");
	flux.flux_time_type              .set("fluxsim.0.flux_time_type"         , SP_DATTYPE::SP_STRING    ,                  "1",       "none",    false,    "combo", "Sun position=0;Hour/Day=1",    false,           "Simulation time spec. method", "Method for specifying the desired flux simulation time.");
	flux.is_autoscale                .set("fluxsim.0.is_autoscale"           , SP_DATTYPE::SP_BOOL      ,               "True",       "none",    false, "checkbox",    "",    false,                              "Autoscale", "Autoscale the Z-axis of the contour plot");
	flux.is_cloud_pattern            .set("fluxsim.0.is_cloud_pattern"       , SP_DATTYPE::SP_BOOL      ,               "True",           "",     true, "checkbox",    "",    false,                   "Enable cloud pattern", "Create a pattern based on the specified cloud");
	flux.is_cloud_symd               .set("fluxsim.0.is_cloud_symd"          , SP_DATTYPE::SP_BOOL      ,               "True",           "",     true, "checkbox",    "",    false,   "Pattern symmetric in depth direction", "Mirror the cloud pattern below the width axis");
	flux.is_cloud_symw               .set("fluxsim.0.is_cloud_symw"          , SP_DATTYPE::SP_BOOL      ,               "True",           "",     true, "checkbox",    "",    false,   "Pattern symmetric in width direction", "Mirror the cloud pattern to the left of the depth axis");
	flux.is_cloudy                   .set("fluxsim.0.is_cloudy"              , SP_DATTYPE::SP_BOOL      ,              "False",           "",     true, "checkbox",    "",    false,               "Simulate cloud transient", "Enable simulation for a cloud transient");
	flux.is_dynamic_group            .set("fluxsim.0.is_dynamic_group"       , SP_DATTYPE::SP_BOOL      ,               "True",       "none",    false, "checkbox",    "",    false,     "Include dynamic heliostat grouping", "Include the dynamic heliostat grouping methodology in the SolTrace simulation");
	flux.is_load_raydata             .set("fluxsim.0.is_load_raydata"        , SP_DATTYPE::SP_BOOL      ,              "False",       "none",     true, "checkbox",    "",     true,       "Load existing heliostat ray data", "Load heliostat field raytrace data from an existing file");
	flux.is_optical_err              .set("fluxsim.0.is_optical_err"         , SP_DATTYPE::SP_BOOL      ,               "True",           "",    false, "checkbox",    "",    false,                 "Include optical errors", "Include the reflector optical error sources in the SolTrace simulation");
	flux.is_save_raydata             .set("fluxsim.0.is_save_raydata"        , SP_DATTYPE::SP_BOOL      ,              "False",       "none",     true, "checkbox",    "",     true,          "Save heliostat stage ray data", "Save heliostat field raytrace data to a file for future re-use");
	flux.is_sunshape_err             .set("fluxsim.0.is_sunshape_err"        , SP_DATTYPE::SP_BOOL      ,               "True",           "",    false, "checkbox",    "",    false,                      "Include sun shape", "Include the sun shape error in the SolTrace simulation");
	flux.max_rays                    .set("fluxsim.0.max_rays"               , SP_DATTYPE::SP_INT       ,            "1000000",       "none",     true,         "",    "",    false,       "Maximum number of generated rays", "The maximum number of generated rays allowed before terminating the simulation. Overrides the desired rays setting.");
	flux.min_rays                    .set("fluxsim.0.min_rays"               , SP_DATTYPE::SP_INT       ,              "10000",       "none",     true,         "",    "",    false,    "Desired number of ray intersections", "The minimum number of ray hits on the receiver before terminating the simulation.");
	flux.multi_rec_aim_rand          .set("fluxsim.0.multi_rec_aim_rand"     , SP_DATTYPE::SP_DOUBLE    ,                "0.0",       "none",     true,         "",    "",    false,  "Multi-receiver aimpoint randomization", "Factor from 0-1 indicating extent of random sampling in assigning heliostats to receivers. 1=completely random.");
	flux.norm_dist_sigma             .set("fluxsim.0.norm_dist_sigma"        , SP_DATTYPE::SP_DOUBLE    ,               "0.25",           "",     true,         "",    "",    false,      "Aiming distribution standard dev.", "Size of the standard distribution relative to half of the height of the receiver.");
	flux.plot_zmax                   .set("fluxsim.0.plot_zmax"              , SP_DATTYPE::SP_DOUBLE    ,             "1000.0",       "none",    false,         "",    "",    false,                                    "Max", "Z-axis maximum value");
	flux.plot_zmin                   .set("fluxsim.0.plot_zmin"              , SP_DATTYPE::SP_DOUBLE    ,                "0.0",       "none",    false,         "",    "",    false,                                    "Min", "Z-axis minimum value");
	flux.raydata_file                .set("fluxsim.0.raydata_file"           , SP_DATTYPE::SP_STRING    ,        "raydata.dat",       "none",     true,     "path",    "",     true,                          "Ray data file", "Location and file of the ray data");
	flux.save_data                   .set("fluxsim.0.save_data"              , SP_DATTYPE::SP_BOOL      ,              "False",           "",    false, "checkbox",    "",    false,                 "Save all raytrace data", "Save the results for each ray");
	flux.save_data_loc               .set("fluxsim.0.save_data_loc"          , SP_DATTYPE::SP_STRING    , "soltrace_ray_data.csv",           "",    false,         "",    "",    false,                               "ray data", "Choose a location to save the ray data");
	flux.seed                        .set("fluxsim.0.seed"                   , SP_DATTYPE::SP_INT       ,                 "-1",       "none",    false,         "",    "",    false, "Seed value (-1 for automatic selection)", "The seed for the random number generator");
	flux.sigma_limit_x               .set("fluxsim.0.sigma_limit_x"          , SP_DATTYPE::SP_DOUBLE    ,                "2.0",           "",     true,         "",    "",    false, "Min. image offset from receiver edge - X", "Minimum distance (std. dev.) between optical center of heliostat image and the receiver edge in the receiver-X direction");
	flux.sigma_limit_y               .set("fluxsim.0.sigma_limit_y"          , SP_DATTYPE::SP_DOUBLE    ,                "2.0",       "none",     true,         "",    "",    false, "Min. image offset from receiver edge - Y", "Minimum distance (std. dev.) between optical center of heliostat image and the receiver edge in the receiver-Y direction");
	flux.x_res                       .set("fluxsim.0.x_res"                  , SP_DATTYPE::SP_INT       ,                 "25",       "none",     true,         "",    "",    false,      "Flux grid resolution - Horizontal", "Number of flux test points per panel (maximum) in the vertical direction for the flux simulation");
	flux.y_res                       .set("fluxsim.0.y_res"                  , SP_DATTYPE::SP_INT       ,                 "25",       "none",     true,         "",    "",    false,        "Flux grid resolution - Vertical", "Number of flux test points per panel (maximum) in the horizontal direction for the flux simulation");
	flux.flux_solar_az               .setup("fluxsim.0.flux_solar_az"          , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false,         "Calculated solar azimuth angle", "Solar azimuth angle to use for the flux simulation");
	flux.flux_solar_el               .setup("fluxsim.0.flux_solar_el"          , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false,       "Calculated solar elevation angle", "Solar elevation angle to use for the flux simulation");

	land.class_name                  .set("land.0.class_name"                , SP_DATTYPE::SP_STRING    ,               "Land",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	land.exclusions                  .set("land.0.exclusions"                , SP_DATTYPE::SP_DVEC_POINT,                   "",           "",    false,         "",    "",    false,                             "exclusions", "Vector of arrays that specify the regions of land to exclude in the heliostat layout");
	land.import_tower_lat            .set("land.0.import_tower_lat"          , SP_DATTYPE::SP_DOUBLE    ,                "0.0",        "deg",    false,         "",    "",    false,  "Imported land boundary tower latitude", "Imported land boundary tower latitude");
	land.import_tower_lon            .set("land.0.import_tower_lon"          , SP_DATTYPE::SP_DOUBLE    ,                "0.0",        "deg",    false,         "",    "",    false, "Imported land boundary tower longitude", "Imported land boundary tower longitude");
	land.import_tower_set            .set("land.0.import_tower_set"          , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false,         "",    "",    false,      "Imported land boundary tower flag", "Has the tower location been set for imported land geometries?");
	land.inclusions                  .set("land.0.inclusions"                , SP_DATTYPE::SP_DVEC_POINT,                   "",           "",    false,         "",    "",    false,                             "inclusions", "Vector of arrays that specify the regions of land to include in the heliostat layout");
	land.is_bounds_array             .set("land.0.is_bounds_array"           , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,                "Use land boundary array", "Land boundary is specified by points array");
	land.is_bounds_fixed             .set("land.0.is_bounds_fixed"           , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,                  "Use fixed land bounds", "Land boundary has fixed limits (not more than | not less than)");
	land.is_bounds_scaled            .set("land.0.is_bounds_scaled"          , SP_DATTYPE::SP_BOOL      ,               "True",       "none",    false, "checkbox",    "",    false,         "Bounds scale with tower height", "Land boundary scales with tower hight value");
	land.is_exclusions_relative      .set("land.0.is_exclusions_relative"    , SP_DATTYPE::SP_BOOL      ,              "False",       "none",     true, "checkbox",    "",    false,  "Exclusions relative to tower position", "Shift the exclusion regions along with the tower offset values");
	land.land_const                  .set("land.0.land_const"                , SP_DATTYPE::SP_DOUBLE    ,               "45.0",       "acre",     true,         "",    "",    false,              "Non-solar field land area", "Fixed land area that is added to the area occupied by heliostats");
	land.land_mult                   .set("land.0.land_mult"                 , SP_DATTYPE::SP_DOUBLE    ,                "1.3",       "none",     true,         "",    "",    false,       "Solar field land area multiplier", "Factor multiplying the land area occupied by heliostats");
	land.max_fixed_rad               .set("land.0.max_fixed_rad"             , SP_DATTYPE::SP_DOUBLE    ,             "2000.0",          "m",     true,         "",    "",    false,            "Maximum land radius (fixed)", "Outer land boundary for circular land plot");
	land.max_scaled_rad              .set("land.0.max_scaled_rad"            , SP_DATTYPE::SP_DOUBLE    ,                "9.5",       "none",     true,         "",    "",    false,                   "Maximum field radius", "Maximum radius (in units of tower height) for positioning of the heliostats");
	land.min_fixed_rad               .set("land.0.min_fixed_rad"             , SP_DATTYPE::SP_DOUBLE    ,              "100.0",          "m",     true,         "",    "",    false,            "Minimum land radius (fixed)", "Inner land boundary for circular land plot");
	land.min_scaled_rad              .set("land.0.min_scaled_rad"            , SP_DATTYPE::SP_DOUBLE    ,               "0.75",       "none",     true,         "",    "",    false,                   "Minimum field radius", "Minimum radius (in units of tower height) for positioning of the heliostats");
	land.tower_offset_x              .set("land.0.tower_offset_x"            , SP_DATTYPE::SP_DOUBLE    ,                "0.0",          "m",     true,         "",    "",    false,              "Tower location offset - X", "Displacement of the tower in X relative to the X-positions specified in the land table");
	land.tower_offset_y              .set("land.0.tower_offset_y"            , SP_DATTYPE::SP_DOUBLE    ,                "0.0",          "m",     true,         "",    "",    false,              "Tower location offset - Y", "Displacement of the tower in Y relative to the Y-positions specified in the land table");
	land.bound_area                  .setup("land.0.bound_area"                , SP_DATTYPE::SP_DOUBLE    ,                             "acre",    false,         "",    "",    false,                  "Solar field land area", "Land area occupied by heliostats. This value is the area of a convex hull surrounding the heliostat positions.");
	land.land_area                   .setup("land.0.land_area"                 , SP_DATTYPE::SP_DOUBLE    ,                             "acre",    false,         "",    "",    false,                        "Total land area", "Land area, including solar field and multiplying factor");
	land.radmax_m                    .setup("land.0.radmax_m"                  , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,             "Maximum heliostat distance", "Calculated maximum distance between tower and last row of heliostats");
	land.radmin_m                    .setup("land.0.radmin_m"                  , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,             "Minimum heliostat distance", "Calculated minimum distance between tower and first row of heliostats");

	opt.algorithm                    .set("optimize.0.algorithm"             , SP_DATTYPE::SP_STRING    ,                  "1",           "",     true,    "combo", "BOBYQA=0;COBYLA=1;NEWOUA=2;Nelder-Mead=3;Subplex=4;RSGS=5",     true,                 "Optimization algorithm", "Optimization algorithm");
	opt.class_name                   .set("optimize.0.class_name"            , SP_DATTYPE::SP_STRING    ,       "Optimization",           "",    false,         "",    "",    false,                                       "", "");
	opt.converge_tol                 .set("optimize.0.converge_tol"          , SP_DATTYPE::SP_DOUBLE    ,             "0.0001",       "none",     true,         "",    "",    false,                  "Convergence tolerance", "Relative change in the objective function below which convergence is achieved");
	opt.flux_penalty                 .set("optimize.0.flux_penalty"          , SP_DATTYPE::SP_DOUBLE    ,               "0.35",       "none",     true,         "",    "",     true,                   "Flux overage penalty", "Relative weight in the objective function given to flux intensity over the allowable limit");
	opt.is_log_to_file               .set("optimize.0.is_log_to_file"        , SP_DATTYPE::SP_BOOL      ,               "True",       "none",    false, "checkbox",    "",    false,                       "Echo log to file", "Write log messages to a file on disk during optimization iterations");
	opt.log_file_path                .set("optimize.0.log_file_path"         , SP_DATTYPE::SP_STRING    , "optimization_log.txt",       "none",    false,     "path",    "",    false,                      "Log file location", "Log file location");
	opt.max_desc_iter                .set("optimize.0.max_desc_iter"         , SP_DATTYPE::SP_INT       ,                 "20",       "none",    false,         "",    "",     true,      "Max. no. continuous descent steps", "Maximum number of steps along the direction of steepest descent before recalculating the response surface");
	opt.max_gs_iter                  .set("optimize.0.max_gs_iter"           , SP_DATTYPE::SP_INT       ,                  "5",       "none",    false,         "",    "",     true,             "Max. refinement iterations", "Maximum number of golden section iterations to refine the position of a local minimum");
	opt.max_iter                     .set("optimize.0.max_iter"              , SP_DATTYPE::SP_INT       ,                "200",       "none",     true,         "",    "",    false,                     "Maximum iterations", "Maximum number of times the optimization can iterate");
	opt.max_step                     .set("optimize.0.max_step"              , SP_DATTYPE::SP_DOUBLE    ,               "0.06",       "none",     true,         "",    "",    false,                      "Initial step size", "Maximum total relative step size during optimization");
	opt.multirec_opt_timeout         .set("optimize.0.multirec_opt_timeout"  , SP_DATTYPE::SP_DOUBLE    ,               "60.0",        "sec",    false,         "",    "",    false, "Multi-receiver optimization solver time", "Maximum allowable solver time for multiple receiver heliostat position and aimpoint optimization");
	opt.multirec_screen_mult         .set("optimize.0.multirec_screen_mult"  , SP_DATTYPE::SP_DOUBLE    ,               "1.25",       "none",    false,         "",    "",    false, "Multi-receiver heliostat screen fraction", "The number of heliostats required to meet this value times the design power of each receiver are considered for layout");
	opt.power_penalty                .set("optimize.0.power_penalty"         , SP_DATTYPE::SP_DOUBLE    ,                "2.0",       "none",     true,         "",    "",    false,                 "Power shortage penalty", "Relative weight in the objective function given to power to the receiver below the required minimum");
	opt.aspect_display               .setup("optimize.0.aspect_display"        , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,    "Current receiver aspect ratio (H/W)", "Current receiver aspect ratio (H/W)");
	opt.gs_refine_ratio              .setup("optimize.0.gs_refine_ratio"       , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",     true,       "Refinement relative bounding box", "The relative step size of the refined area during refinement simulations. More iterations will allow greater refinement");

	par.class_name                   .set("parametric.0.class_name"          , SP_DATTYPE::SP_STRING    , "Parametric Simulation",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	par.eff_file_name                .set("parametric.0.eff_file_name"       , SP_DATTYPE::SP_STRING    ,      "eff_array.csv",           "",    false,         "",    "",    false,                   "Efficiency file name", "Name of the output file containing the efficiency matrix");
	par.flux_file_name               .set("parametric.0.flux_file_name"      , SP_DATTYPE::SP_STRING    ,        "fluxmap.csv",           "",    false,         "",    "",    false,                      "Fluxmap file name", "Name of the output file containing the fluxmap data");
	par.fluxmap_format               .set("parametric.0.fluxmap_format"      , SP_DATTYPE::SP_STRING    ,                  "0",           "",    false,    "combo", "SAM format=0;12x10 array=1;Specified dimensions=2",    false,                "Fluxmap data dimensions", "Dimensions of the fluxmap data (rows,cols)");
	par.is_fluxmap_norm              .set("parametric.0.is_fluxmap_norm"     , SP_DATTYPE::SP_BOOL      ,               "True",           "",    false, "checkbox",    "",    false,                    "Normalize flux data", "Flux data is reported as normalized");
	par.par_save_field_img           .set("parametric.0.par_save_field_img"  , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,                       "Save field image", "Save field image based on selected options");
	par.par_save_flux_dat            .set("parametric.0.par_save_flux_dat"   , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,                "Save receiver flux data", "Save receiver flux data");
	par.par_save_flux_img            .set("parametric.0.par_save_flux_img"   , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,               "Save receiver flux image", "Save receiver flux image");
	par.par_save_helio               .set("parametric.0.par_save_helio"      , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,        "Save heliostat performance data", "Save detailed heliostat performance data for each run");
	par.par_save_summary             .set("parametric.0.par_save_summary"    , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,   "Save performance summary information", "Save detailed system performance data to a file for each run");
	par.sam_grid_format              .set("parametric.0.sam_grid_format"     , SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "Auto spacing=0;Even grid=1",    false,                   "SAM data grid format", "SAM data grid format");
	par.sam_out_dir                  .set("parametric.0.sam_out_dir"         , SP_DATTYPE::SP_STRING    ,                   "",           "",    false,         "",    "",    false,                       "Output directory", "Output directory");
	par.upar_save_field_img          .set("parametric.0.upar_save_field_img" , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,                "Save field image (User)", "Save field image based on selected options");
	par.upar_save_flux_dat           .set("parametric.0.upar_save_flux_dat"  , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,         "Save receiver flux data (User)", "Save receiver flux data");
	par.upar_save_flux_img           .set("parametric.0.upar_save_flux_img"  , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,        "Save receiver flux image (User)", "Save receiver flux image");
	par.upar_save_helio              .set("parametric.0.upar_save_helio"     , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false, "Save heliostat performance data (User)", "Save detailed heliostat performance data for each run");
	par.upar_save_summary            .set("parametric.0.upar_save_summary"   , SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,   "Save performance summary info (User)", "Save detailed system performance data to a file for each run");
	par.user_par_values              .set("parametric.0.user_par_values"     , SP_DATTYPE::SP_STRING    ,                   "",       "none",    false,         "",    "",    false,                 "User parametric values", "User parametric values");

	sf.accept_max                    .set("solarfield.0.accept_max"          , SP_DATTYPE::SP_DOUBLE    ,              "180.0",        "deg",     true,         "",    "",    false,       "Maximum solar field extent angle", "Upper bound of the angular range containing the heliostat field");
	sf.accept_min                    .set("solarfield.0.accept_min"          , SP_DATTYPE::SP_DOUBLE    ,             "-180.0",        "deg",     true,         "",    "",    false,       "Minimum solar field extent angle", "Lower bound of the angular range containing the heliostat field");
	sf.az_spacing                    .set("solarfield.0.az_spacing"          , SP_DATTYPE::SP_DOUBLE    ,                "2.0",       "none",     true,         "",    "",    false,               "Azimuthal spacing factor", "Azimuthal spacing factor for the first row of heliostats after a reset. Heliostats separated by heliostat width times this factor.");
	sf.class_name                    .set("solarfield.0.class_name"          , SP_DATTYPE::SP_STRING    ,        "Solar Field",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	sf.des_sim_detail                .set("solarfield.0.des_sim_detail"      , SP_DATTYPE::SP_STRING    ,                  "5",       "none",     true,    "combo", "Subset of days/hours=2;Single simulation point=1;Do not filter heliostats=0;Annual simulation=3;Limited annual simulation=4;Representative profiles=5;Efficiency map + annual=6",    false,               "Optimization simulations", "Simulation detail for placing heliostats (see definitions in options spreadsheet)");
	sf.des_sim_ndays                 .set("solarfield.0.des_sim_ndays"       , SP_DATTYPE::SP_INT       ,                  "4",       "none",     true,         "",    "",    false,             "Number of days to simulate", "For limited annual simulation, the number of evenly spaced days to simulate");
	sf.des_sim_nhours                .set("solarfield.0.des_sim_nhours"      , SP_DATTYPE::SP_INT       ,                  "2",       "none",     true,         "",    "",    false,              "Simulation hour frequency", "Simulation will run with the specified hourly frequency (1=every hour, 2=every other hour...)");
	sf.dni_des                       .set("solarfield.0.dni_des"             , SP_DATTYPE::SP_DOUBLE    ,              "950.0",       "W/m2",     true,         "",    "",    false,                 "Design-point DNI value", "DNI value at which the design-point receiver thermal power is achieved");
	sf.hsort_method                  .set("solarfield.0.hsort_method"        , SP_DATTYPE::SP_STRING    ,                  "7",       "none",     true,    "combo", "Power to receiver=0;Total efficiency=1;Cosine efficiency=2;Attenuation efficiency=3;Intercept efficiency=4;Blocking efficiency=5;Shadowing efficiency=6;TOU-weighted power=7",    false,           "Heliostat selection criteria", "Select the criteria by which heliostats will be included in the solar field layout.");
	sf.interaction_limit             .set("solarfield.0.interaction_limit"   , SP_DATTYPE::SP_DOUBLE    ,              "100.0",   "helio-ht",     true,         "",    "",    false,    "Heliostat shading interaction limit", "Multiply the heliostat height to determine the radius of possible interaction with other heliostats");
	sf.is_multirec_powfrac           .set("solarfield.0.is_multirec_powfrac" , SP_DATTYPE::SP_BOOL      ,              "False",       "none",     true, "checkbox",    "",    false, "Specify multi-receiver power fractions", "Enables the user to specify the fraction of power delivered from the heliostat to each receiver");
	sf.is_opt_zoning                 .set("solarfield.0.is_opt_zoning"       , SP_DATTYPE::SP_BOOL      ,               "True",       "none",    false, "checkbox",    "",    false,      "Enable optical layout zone method", "Enables grouping of heliostats into zones for intercept factor calculation during layout only");
	sf.is_prox_filter                .set("solarfield.0.is_prox_filter"      , SP_DATTYPE::SP_BOOL      ,              "False",       "none",     true, "checkbox",    "",    false,                 "Apply proximity filter", "Post-process the layout to select heliostats that are closer to the tower.");
	sf.is_sliprow_skipped            .set("solarfield.0.is_sliprow_skipped"  , SP_DATTYPE::SP_BOOL      ,              "False",       "none",     true, "checkbox",    "",    false,         "Offset slip plane for blocking", "Radial gap before first row after slip plane is sufficient to eliminate blocking");
	sf.is_tht_opt                    .set("solarfield.0.is_tht_opt"          , SP_DATTYPE::SP_BOOL      ,               "True",       "none",    false, "checkbox",    "",    false,                  "Optimize tower height", "Vary the tower height during optimization to identify optimal level?");
	sf.layout_data                   .set("solarfield.0.layout_data"         , SP_DATTYPE::SP_STRING    ,                   "",           "",    false,         "",    "",    false,             "Layout data in string form", "Layout data in string form");
	sf.layout_method                 .set("solarfield.0.layout_method"       , SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "Radial Stagger=1;Cornfield=2;User-defined=3",    false,                          "Layout method", "Field layout method");
	sf.max_zone_size_az              .set("solarfield.0.max_zone_size_az"    , SP_DATTYPE::SP_DOUBLE    ,                "1.0",   "tower-ht",     true,         "",    "",    false, "Max. optical layout zone size - azimuthal", "Maximum zone size (azimuthal direction) for grouping optical intercept factor calculations");
	sf.max_zone_size_rad             .set("solarfield.0.max_zone_size_rad"   , SP_DATTYPE::SP_DOUBLE    ,                "1.0",   "tower-ht",     true,         "",    "",    false, "Max. optical layout zone size - radial", "Maximum zone size (radial direction) for grouping optical intercept factor calculations");
	sf.min_zone_size_az              .set("solarfield.0.min_zone_size_az"    , SP_DATTYPE::SP_DOUBLE    ,                "0.1",   "tower-ht",     true,         "",    "",    false, "Min. optical layout zone size - azimuthal", "Minimum zone size (azimuthal direction) for grouping optical intercept factor calculations");
	sf.min_zone_size_rad             .set("solarfield.0.min_zone_size_rad"   , SP_DATTYPE::SP_DOUBLE    ,                "0.1",   "tower-ht",     true,         "",    "",    false, "Min. optical layout zone size - radial", "Minimum zone size (radial direction) for grouping optical intercept factor calculations");
	sf.prox_filter_frac              .set("solarfield.0.prox_filter_frac"    , SP_DATTYPE::SP_DOUBLE    ,               "0.03",       "none",     true,         "",    "",    false,              "Proximity filter fraction", "Fraction of heliostats to subject to proximity filter.");
	sf.q_des                         .set("solarfield.0.q_des"               , SP_DATTYPE::SP_DOUBLE    ,              "670.0",        "MWt",     true,         "",    "",    false,               "Solar field design power", "Design thermal power delivered from the solar field");
	sf.rad_spacing_method            .set("solarfield.0.rad_spacing_method"  , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "No blocking-dense=3;Eliminate blocking=2;DELSOL Empirical Fit=1",    false,                  "Radial spacing method", "Method for determining radial spacing during field layout for radial-stagger");
	sf.row_spacing_x                 .set("solarfield.0.row_spacing_x"       , SP_DATTYPE::SP_DOUBLE    ,                "1.1",       "none",     true,         "",    "",    false, "Heliostat spacing factor - X direction", "Separation between adjacent heliostats in the X-direction, multiplies heliostat radius");
	sf.row_spacing_y                 .set("solarfield.0.row_spacing_y"       , SP_DATTYPE::SP_DOUBLE    ,                "1.1",       "none",     true,         "",    "",    false, "Heliostat spacing factor - Y direction", "Separation between adjacent heliostats in the Y-direction, multiplies heliostat radius");
	sf.shadow_height                 .set("solarfield.0.shadow_height"       , SP_DATTYPE::SP_DOUBLE    ,              "195.0",          "m",    false,         "",    "",    false,                    "Tower shadow height", "Effective tower height for shadowing calculations");
	sf.shadow_width                  .set("solarfield.0.shadow_width"        , SP_DATTYPE::SP_DOUBLE    ,               "16.0",          "m",    false,         "",    "",    false,                     "Tower shadow width", "Effective tower diameter for shadowing calculations");
	sf.slip_plane_blocking           .set("solarfield.0.slip_plane_blocking" , SP_DATTYPE::SP_DOUBLE    ,                "0.5",       "none",     true,         "",    "",    false,       "Allowable blocking in slip plane", "Allowable blocking in slip plane");
	sf.spacing_reset                 .set("solarfield.0.spacing_reset"       , SP_DATTYPE::SP_DOUBLE    ,               "1.33",       "none",     true,         "",    "",    false,          "Azimuthal spacing reset limit", "For heliostat layout - ratio of maximum to initial azimuthal spacing before starting new compressed row");
	sf.sun_az_des_user               .set("solarfield.0.sun_az_des_user"     , SP_DATTYPE::SP_DOUBLE    ,              "180.0",        "deg",     true,         "",    "",    false,   "Specified design-point solar azimuth", "Solar azimuth angle at the design point");
	sf.sun_el_des_user               .set("solarfield.0.sun_el_des_user"     , SP_DATTYPE::SP_DOUBLE    ,               "85.0",        "deg",     true,         "",    "",    false, "Specified design-point solar elevation", "Solar elevation angle at the design point");
	sf.sun_loc_des                   .set("solarfield.0.sun_loc_des"         , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "Summer solstice=0;Equinox=1;Winter solstice=2;Zenith=3;Other..=4",    false,           "Sun location at design point", "Sun location when thermal power rating is achieved");
	sf.temp_which                    .set("solarfield.0.temp_which"          , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo",    "",    false,              "Select heliostat geometry", "Select the heliostat geometry template that will be used in the layout");
	sf.template_rule                 .set("solarfield.0.template_rule"       , SP_DATTYPE::SP_STRING    ,                  "0",           "",     true,    "combo", "Use single template=0;Specified range=1;Even radial distribution=2",    false,        "Heliostat geometry distribution", "Method for distributing heliostat geometry templates in the field");
	sf.tht                           .set("solarfield.0.tht"                 , SP_DATTYPE::SP_DOUBLE    ,              "195.0",          "m",     true,         "",    "",    false,                   "Tower optical height", "Average height of the tower receiver centerline above the base heliostat pivot point elevation");
	sf.trans_limit_fact              .set("solarfield.0.trans_limit_fact"    , SP_DATTYPE::SP_DOUBLE    ,                "1.0",       "none",     true,         "",    "",    false,        "Packing transition limit factor", "Determines the point at which close-packing switches to standard layout. =1 at no-blocking transition limit.");
	sf.version                       .set("solarfield.0.version"             , SP_DATTYPE::SP_STRING    ,                   "",       "none",    false,         "",    "",    false,    "SolarPILOT code base version number", "SolarPILOT code base version number");
	sf.xy_field_shape                .set("solarfield.0.xy_field_shape"      , SP_DATTYPE::SP_STRING    ,                  "0",           "",     true,    "combo", "Hexagon=0;Rectangle=1;Undefined=2",    false,           "Heliostat field layout shape", "Enforced shape of the heliostat field");
	sf.xy_rect_aspect                .set("solarfield.0.xy_rect_aspect"      , SP_DATTYPE::SP_DOUBLE    ,                "1.0",       "none",     true,         "",    "",    false,              "Layout aspect ratio (Y/X)", "Aspect ratio of the rectangular field layout (height in Y / width in X)");
	sf.zone_div_tol                  .set("solarfield.0.zone_div_tol"        , SP_DATTYPE::SP_DOUBLE    ,              "0.001",       "none",     true,         "",    "",    false,     "Optical layout zone mesh tolerance", "Allowable variation in optical intercept factor within a layout zone");
	sf.rec_area                      .setup("solarfield.0.rec_area"            , SP_DATTYPE::SP_DOUBLE    ,                               "m2",    false,         "",    "",    false,            "Total receiver surface area", "Surface area from all receivers included in the solar field");
	sf.sf_area                       .setup("solarfield.0.sf_area"             , SP_DATTYPE::SP_DOUBLE    ,                               "m2",    false,         "",    "",    false,                 "Total solar field area", "The sum of all heliostat reflector area in the current layout");
	sf.sim_step_data                 .setup("solarfield.0.sim_step_data"       , SP_DATTYPE::SP_WEATHERDATA,                             "none",    false,         "",    "",    false,       "Data used for design simulations", "Data used for design simulations");
	sf.sun_az_des                    .setup("solarfield.0.sun_az_des"          , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false,  "Calculated design-point solar azimuth", "Calculated design-point solar azimuth");
	sf.sun_el_des                    .setup("solarfield.0.sun_el_des"          , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false, "Calculated design-point solar elevation", "Calculated design-point solar elevation");

	amb.addptrs( _varptrs );
	fin.addptrs( _varptrs );
	flux.addptrs( _varptrs );
	land.addptrs( _varptrs );
	opt.addptrs( _varptrs );
	par.addptrs( _varptrs );
	sf.addptrs( _varptrs );

    add_heliostat(0);
    add_receiver(0);
    
}

void var_map::add_heliostat(int id)
{
	std::string sid=my_to_string(id);
	hels.push_back(var_heliostat());

	hels.back().cant_day             .set("heliostat."+sid+".cant_day"       , SP_DATTYPE::SP_INT       ,                 "82",        "day",     true,         "",    "",    false,                "Canting day of the year", "Day of the year used for canting the heliostats (1-365)");
	hels.back().cant_hour            .set("heliostat."+sid+".cant_hour"      , SP_DATTYPE::SP_DOUBLE    ,                "0.0",         "hr",     true,         "",    "",    false,               "Canting hour (past noon)", "Hours past noon at which the mirror panels are canted (-12 to 12)");
	hels.back().cant_method          .set("heliostat."+sid+".cant_method"    , SP_DATTYPE::SP_STRING    ,                  "1",       "none",     true,    "combo", "No canting=0;On-axis at slant=-1;On-axis, user-defined=1;Off-axis, day and hour=3;User-defined vector=4",    false,               "Heliostat canting method", "Integer to specify the canting method {0=none, -1=Cant on-axis equal to slant range, 1=user-defined on-axis, 3=user-defined off-axis at hour + day}");
	hels.back().cant_rad_scaled      .set("heliostat."+sid+".cant_rad_scaled", SP_DATTYPE::SP_DOUBLE    ,                "6.0",       "none",     true,         "",    "",    false,                  "Canting radius factor", "Canting radius value (absolute value if radius is not scaled, multiplied by tower height if scaled)");
	hels.back().cant_vect_i          .set("heliostat."+sid+".cant_vect_i"    , SP_DATTYPE::SP_DOUBLE    ,                "0.0",       "none",     true,         "",    "",    false,             "Canting vector x-component", "Canting vector - x-component");
	hels.back().cant_vect_j          .set("heliostat."+sid+".cant_vect_j"    , SP_DATTYPE::SP_DOUBLE    ,                "0.0",       "none",     true,         "",    "",    false,             "Canting vector y-component", "Canting vector y-component");
	hels.back().cant_vect_k          .set("heliostat."+sid+".cant_vect_k"    , SP_DATTYPE::SP_DOUBLE    ,                "1.0",       "none",     true,         "",    "",    false,             "Canting vector z-component", "Canting vector z-component");
	hels.back().cant_vect_scale      .set("heliostat."+sid+".cant_vect_scale", SP_DATTYPE::SP_DOUBLE    ,              "400.0",          "m",     true,         "",    "",    false,               "Canting vector magnitude", "Value to scale the canting unit vector to determine actual canting magnitude");
	hels.back().cbdata               .set("heliostat."+sid+".cbdata"         , SP_DATTYPE::SP_VOIDPTR   ,                  "0",       "none",    false,         "",    "",    false,               "Data pointer for UI page", "Data pointer for UI page");
	hels.back().class_name           .set("heliostat."+sid+".class_name"     , SP_DATTYPE::SP_STRING    ,          "Heliostat",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	hels.back().diameter             .set("heliostat."+sid+".diameter"       , SP_DATTYPE::SP_DOUBLE    ,              "13.77",          "m",     true,         "",    "",    false,                     "Heliostat diameter", "Diameter of the heliostat structure (round heliostats only)");
	hels.back().err_azimuth          .set("heliostat."+sid+".err_azimuth"    , SP_DATTYPE::SP_DOUBLE    ,                "0.0",        "rad",     true,         "",    "",    false,                 "Azimuth pointing error", "Standard deviation of the normal error dist. of the azimuth angle");
	hels.back().err_elevation        .set("heliostat."+sid+".err_elevation"  , SP_DATTYPE::SP_DOUBLE    ,                "0.0",        "rad",     true,         "",    "",    false,               "Elevation pointing error", "Standard deviation of the normal error dist. of the elevation angle");
	hels.back().err_reflect_x        .set("heliostat."+sid+".err_reflect_x"  , SP_DATTYPE::SP_DOUBLE    ,             "0.0002",        "rad",     true,         "",    "",    false,              "Reflected beam error in X", "error in reflected vector (horiz.) caused by atmospheric refraction, tower sway, etc.");
	hels.back().err_reflect_y        .set("heliostat."+sid+".err_reflect_y"  , SP_DATTYPE::SP_DOUBLE    ,             "0.0002",        "rad",     true,         "",    "",    false,              "Reflected beam error in Y", "error in reflected vector (vert.) caused by atmospheric refraction, tower sway, etc.");
	hels.back().err_surface_x        .set("heliostat."+sid+".err_surface_x"  , SP_DATTYPE::SP_DOUBLE    ,            "0.00153",        "rad",     true,         "",    "",    false,               "Surface slope error in X", "Std.dev. of the normal error dist. of the reflective surface normal in the X (horizontal)");
	hels.back().err_surface_y        .set("heliostat."+sid+".err_surface_y"  , SP_DATTYPE::SP_DOUBLE    ,            "0.00153",        "rad",     true,         "",    "",    false,               "Surface slope error in Y", "Same as above, but in the vertical direction");
	hels.back().focus_method         .set("heliostat."+sid+".focus_method"   , SP_DATTYPE::SP_STRING    ,                  "1",       "none",     true,    "combo", "Flat=0;At slant=1;Group average=2;User-defined=3",    false,                "Heliostat focusing type", "The focusing method {0=Flat, 1=Each at slant, 2=Average of group, 3=User defined}");
	hels.back().height               .set("heliostat."+sid+".height"         , SP_DATTYPE::SP_DOUBLE    ,               "12.2",          "m",     true,         "",    "",    false,                       "Structure height", "Height of the heliostat structure");
	hels.back().helio_name           .set("heliostat."+sid+".helio_name"     , SP_DATTYPE::SP_STRING    ,         "Template 1",           "",    false,         "",    "",    false,                "Heliostat template name", "Heliostat template name");
	hels.back().id                   .set("heliostat."+sid+".id"             , SP_DATTYPE::SP_INT       ,                 "-1",       "none",    false,         "",    "",    false,                                     "id", "Unique ID number for the heliostat template");
	hels.back().is_cant_rad_scaled   .set("heliostat."+sid+".is_cant_rad_scaled", SP_DATTYPE::SP_BOOL      ,               "True",           "",    false, "checkbox",    "",    false,    "Scale cant radius with tower height", "The cant radius scales with tower height");
	hels.back().is_cant_vect_slant   .set("heliostat."+sid+".is_cant_vect_slant", SP_DATTYPE::SP_BOOL      ,              "False",       "none",    false, "checkbox",    "",    false,          "Scale vector with slant range", "Multiply the canting vector by the slant range");
	hels.back().is_enabled           .set("heliostat."+sid+".is_enabled"     , SP_DATTYPE::SP_BOOL      ,               "True",           "",    false,         "",    "",    false,                   "Is template enabled?", "Is template enabled?");
	hels.back().is_faceted           .set("heliostat."+sid+".is_faceted"     , SP_DATTYPE::SP_BOOL      ,               "True",       "none",    false, "checkbox",    "",    false,                    "Use multiple panels", "The number of reflective panels per heliostat is greater than 1");
	hels.back().is_focal_equal       .set("heliostat."+sid+".is_focal_equal" , SP_DATTYPE::SP_BOOL      ,               "True",       "none",    false, "checkbox",    "",    false,                "Use single focal length", "Both the X and Y focal lengths will use a single value as indicated by the X focal length");
	hels.back().is_round             .set("heliostat."+sid+".is_round"       , SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "Rectangular=0;Round=1",    false,                        "Heliostat shape", "Is the heliostat round (true) or rectangular (false)");
	hels.back().is_xfocus            .set("heliostat."+sid+".is_xfocus"      , SP_DATTYPE::SP_BOOL      ,               "True",       "none",    false, "checkbox",    "",    false,                             "Focus in X", "Reflector is focused in with respect to the heliostat X axis");
	hels.back().is_yfocus            .set("heliostat."+sid+".is_yfocus"      , SP_DATTYPE::SP_BOOL      ,               "True",       "none",    false, "checkbox",    "",    false,                             "Focus in Y", "Reflector is focused in with respect to the heliostat Y axis");
	hels.back().n_cant_x             .set("heliostat."+sid+".n_cant_x"       , SP_DATTYPE::SP_INT       ,                  "2",           "",     true,         "",    "",    false,                  "No. horizontal panels", "Number of cant panels in the X direction");
	hels.back().n_cant_y             .set("heliostat."+sid+".n_cant_y"       , SP_DATTYPE::SP_INT       ,                  "8",           "",     true,         "",    "",    false,                    "No. vertical panels", "Number of cant panels in the Y direction");
	hels.back().reflect_ratio        .set("heliostat."+sid+".reflect_ratio"  , SP_DATTYPE::SP_DOUBLE    ,               "0.97",       "none",     true,         "",    "",    false,               "Reflective surface ratio", "Ratio of mirror area to total area of the heliostat defined by wm x hm");
	hels.back().reflectivity         .set("heliostat."+sid+".reflectivity"   , SP_DATTYPE::SP_DOUBLE    ,               "0.95",       "none",     true,         "",    "",    false,                    "Mirror reflectivity", "Average reflectivity (clean) of the mirrored surface");
	hels.back().rvel_max_x           .set("heliostat."+sid+".rvel_max_x"     , SP_DATTYPE::SP_DOUBLE    ,             "1000.0",      "rad/s",    false,         "",    "",    false,                             "rvel_max_x", "maximum rotational velocity about the x axis");
	hels.back().rvel_max_y           .set("heliostat."+sid+".rvel_max_y"     , SP_DATTYPE::SP_DOUBLE    ,             "1000.0",      "rad/s",    false,         "",    "",    false,                             "rvel_max_y", "maximum rotational velocity about the z axis");
	hels.back().soiling              .set("heliostat."+sid+".soiling"        , SP_DATTYPE::SP_DOUBLE    ,               "0.95",       "none",     true,         "",    "",    false,                         "Soiling factor", "Average soiling factor");
	hels.back().st_err_type          .set("heliostat."+sid+".st_err_type"    , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "Gaussian=0;Pillbox=1",    false,     "Optical error type (SolTrace only)", "Error distribution of the reflected rays from the heliostat optical surface");
	hels.back().temp_az_max          .set("heliostat."+sid+".temp_az_max"    , SP_DATTYPE::SP_DOUBLE    ,              "180.0",        "deg",    false,         "",    "",    false, "Max. angular boundary for heliostat type", "Angular boundary for heliostat geometry - on the clockwise side of the region");
	hels.back().temp_az_min          .set("heliostat."+sid+".temp_az_min"    , SP_DATTYPE::SP_DOUBLE    ,             "-180.0",        "deg",    false,         "",    "",    false, "Min. angular boundary for heliostat type", "Angular boundary for heliostat geometry - on the counter-clockwise side of the region");
	hels.back().temp_rad_max         .set("heliostat."+sid+".temp_rad_max"   , SP_DATTYPE::SP_DOUBLE    ,               "10.0",       "none",    false,         "",    "",    false,      "Maximum radius for heliostat type", "Maximum radius at which this heliostat geometry can be used");
	hels.back().temp_rad_min         .set("heliostat."+sid+".temp_rad_min"   , SP_DATTYPE::SP_DOUBLE    ,               "0.75",       "none",    false,         "",    "",    false,      "Minimum radius for heliostat type", "Minimum radius at which this heliostat geometry can be used");
	hels.back().template_order       .set("heliostat."+sid+".template_order" , SP_DATTYPE::SP_INT       ,                 "-1",       "none",    false,         "",    "",    false,                         "template_order", "template_order");
	hels.back().track_method         .set("heliostat."+sid+".track_method"   , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "Continuous=0;Periodic=1",     true,       "Heliostat tracking update method", "Specify how often heliostats update their tracking position ");
	hels.back().track_period         .set("heliostat."+sid+".track_period"   , SP_DATTYPE::SP_DOUBLE    ,               "10.0",        "sec",     true,         "",    "",     true,       "Heliostat tracking update period", "The amount of time between tracking updates for each heliostat");
	hels.back().type                 .set("heliostat."+sid+".type"           , SP_DATTYPE::SP_INT       ,                  "0",           "",    false,         "",    "",    false,                                   "type", "Integer used to group heliostats into geometries within a field, (e.g. 5 different focal length designs)");
	hels.back().width                .set("heliostat."+sid+".width"          , SP_DATTYPE::SP_DOUBLE    ,               "12.2",          "m",     true,         "",    "",    false,                        "Structure width", "Width of the heliostat structure");
	hels.back().x_focal_length       .set("heliostat."+sid+".x_focal_length" , SP_DATTYPE::SP_DOUBLE    ,             "1000.0",          "m",     true,         "",    "",    false,                      "Focal length in X", "Reflector focal length with respect to the heliostat X (horizontal) axis");
	hels.back().x_gap                .set("heliostat."+sid+".x_gap"          , SP_DATTYPE::SP_DOUBLE    ,                "0.0",          "m",     true,         "",    "",    false,                  "Cant panel horiz. gap", "Separation between panels in the horizontal direction");
	hels.back().y_focal_length       .set("heliostat."+sid+".y_focal_length" , SP_DATTYPE::SP_DOUBLE    ,             "1000.0",          "m",     true,         "",    "",    false,                      "Focal length in Y", "Reflector focal length with respect to the heliostat Y (vertical) axis");
	hels.back().y_gap                .set("heliostat."+sid+".y_gap"          , SP_DATTYPE::SP_DOUBLE    ,                "0.0",          "m",     true,         "",    "",    false,                   "Cant panel vert. gap", "Separation between panels in the vertical direction");
	hels.back().area                 .setup("heliostat."+sid+".area"           , SP_DATTYPE::SP_DOUBLE    ,                               "m2",    false,         "",    "",    false,         "Total reflective aperture area", "Aperture area including geometry penalties and gaps in the structure");
	hels.back().cant_mag_i           .setup("heliostat."+sid+".cant_mag_i"     , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,               "Total canting vector - i", "Total canting vector - i");
	hels.back().cant_mag_j           .setup("heliostat."+sid+".cant_mag_j"     , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,               "Total canting vector - j", "Total canting vector - j");
	hels.back().cant_mag_k           .setup("heliostat."+sid+".cant_mag_k"     , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,               "Total canting vector - k", "Total canting vector - k");
	hels.back().cant_norm_i          .setup("heliostat."+sid+".cant_norm_i"    , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,          "Normalized canting vector - i", "Normalized canting vector - i");
	hels.back().cant_norm_j          .setup("heliostat."+sid+".cant_norm_j"    , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,          "Normalized canting vector - j", "Normalized canting vector - j");
	hels.back().cant_norm_k          .setup("heliostat."+sid+".cant_norm_k"    , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,          "Normalized canting vector - k", "Normalized canting vector - k");
	hels.back().cant_radius          .setup("heliostat."+sid+".cant_radius"    , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,                         "Canting radius", "Radius for canting focal point assuming on-axis canting");
	hels.back().cant_sun_az          .setup("heliostat."+sid+".cant_sun_az"    , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false,                 "Sun azimuth at canting", "Sun azimuth angle at the moment the cant panels are focused on the receiver");
	hels.back().cant_sun_el          .setup("heliostat."+sid+".cant_sun_el"    , SP_DATTYPE::SP_DOUBLE    ,                              "deg",    false,         "",    "",    false,               "Sun elevation at canting", "Sun elevation angle at the moment the cant panels are focused on the receiver");
	hels.back().err_total            .setup("heliostat."+sid+".err_total"      , SP_DATTYPE::SP_DOUBLE    ,                              "rad",    false,         "",    "",    false,            "Total reflected image error", "Total convolved optical error in the reflected beam from the above sources");
	hels.back().r_collision          .setup("heliostat."+sid+".r_collision"    , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,             "Heliostat collision radius", "Distance between heliostat center and maximum radial extent of structure");
	hels.back().ref_total            .setup("heliostat."+sid+".ref_total"      , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false,              "Total optical reflectance", "Effective reflectance - product of the mirror reflectance and soiling");

	hels.back().id.val = id;
	hels.back().addptrs( _varptrs );
}

void var_map::add_receiver(int id)
{
	std::string sid=my_to_string(id);
	recs.push_back(var_receiver());

	recs.back().absorptance          .set("receiver."+sid+".absorptance"     , SP_DATTYPE::SP_DOUBLE    ,               "0.94",       "none",     true,         "",    "",    false,           "Receiver thermal absorptance", "Energy absorbed by the receiver surface before accounting for radiation/convection losses");
	recs.back().accept_ang_type      .set("receiver."+sid+".accept_ang_type" , SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "Rectangular=0;Elliptical=1",    false,       "Receiver acceptance angles shape", "Receiver angular acceptance window defines angles about the aperture normal, can be rectangular or elliptical shape");
	recs.back().accept_ang_x         .set("receiver."+sid+".accept_ang_x"    , SP_DATTYPE::SP_DOUBLE    ,              "360.0",        "deg",     true,         "",    "",    false,   "Receiver horizontal acceptance angle", "Acceptance angle of the receiver in the horizontal direction (in aperture coordinates)");
	recs.back().accept_ang_y         .set("receiver."+sid+".accept_ang_y"    , SP_DATTYPE::SP_DOUBLE    ,              "180.0",        "deg",     true,         "",    "",    false,     "Receiver vertical acceptance angle", "Acceptance angle of the receiver in the vertical direction (in aperture coordinates)");
	recs.back().aperture_type        .set("receiver."+sid+".aperture_type"   , SP_DATTYPE::SP_STRING    ,                  "0",           "",     true,    "combo", "Rectangular=0",     true,                "Aperture geometry shape", "The shape of the receiver aperture");
	recs.back().cbdata               .set("receiver."+sid+".cbdata"          , SP_DATTYPE::SP_VOIDPTR   ,                  "0",       "none",    false,         "",    "",    false,               "Data pointer for UI page", "Data pointer for UI page");
	recs.back().class_name           .set("receiver."+sid+".class_name"      , SP_DATTYPE::SP_STRING    ,           "Receiver",       "none",    false,         "",    "",    false,                             "Class name", "Class name");
	recs.back().curtain_radius       .set("receiver."+sid+".curtain_radius"  , SP_DATTYPE::SP_DOUBLE    ,               "10.0",          "m",     true,         "",    "",    false,                "Particle curtain radius", "Particle curtain radius of curvature");
	recs.back().curtain_type         .set("receiver."+sid+".curtain_type"    , SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "Flat=0;Curved=1",    false,                  "Particle curtain type", "Particle curtain geometrical configuration");
	recs.back().flux_profile_type    .set("receiver."+sid+".flux_profile_type", SP_DATTYPE::SP_STRING    ,                  "0",       "none",     true,    "combo", "Uniform=0;User=1",    false,          "Desired receiver flux profile", "Desired receiver flux profile type, Image Size Priority mode only");
	recs.back().id                   .set("receiver."+sid+".id"              , SP_DATTYPE::SP_INT       ,                 "-1",           "",    false,         "",    "",    false,                            "Template ID", "Template ID");
	recs.back().is_aspect_opt        .set("receiver."+sid+".is_aspect_opt"   , SP_DATTYPE::SP_BOOL      ,               "True",           "",    false, "checkbox",    "",    false,         "Optimize receiver aspect ratio", "Optimize receiver aspect ratio (height / width)");
	recs.back().is_enabled           .set("receiver."+sid+".is_enabled"      , SP_DATTYPE::SP_BOOL      ,               "True",           "",    false,         "",    "",    false,                   "Is template enabled?", "Is template enabled?");
	recs.back().is_open_geom         .set("receiver."+sid+".is_open_geom"    , SP_DATTYPE::SP_BOOL      ,              "False",           "",    false, "checkbox",    "",     true,        "Limit receiver panel span angle", "If true, the receiver is represented by an arc rather than a closed circle/polygon");
	recs.back().is_polygon           .set("receiver."+sid+".is_polygon"      , SP_DATTYPE::SP_BOOL      ,              "False",           "",     true, "checkbox",    "",     true,          "Represent receiver as polygon", "Receiver geometry is represented as discrete polygon of N panels rather than continuous arc");
	recs.back().is_snout             .set("receiver."+sid+".is_snout"        , SP_DATTYPE::SP_BOOL      ,              "False",           "",    false, "checkbox",    "",    false,                      "Is SNOUT enabled?", "Is SNOUT enabled?");
	recs.back().map_color            .set("receiver."+sid+".map_color"       , SP_DATTYPE::SP_STRING    ,             "random",       "none",    false,         "",    "",    false,           "Specified receiver map color", "Specified receiver map color (hex)");
	recs.back().max_curtain_depth    .set("receiver."+sid+".max_curtain_depth", SP_DATTYPE::SP_DOUBLE    ,                "1.5",          "m",     true,         "",    "",    false,        "Particle curtain entrance depth", "Particle curtain entrance depth from the aperture");
	recs.back().n_panels             .set("receiver."+sid+".n_panels"        , SP_DATTYPE::SP_INT       ,                  "4",       "none",     true,         "",    "",    false,              "Number of receiver panels", "Number of receiver panels (polygon facets) for a polygonal receiver geometry");
	recs.back().norm_curtain_height  .set("receiver."+sid+".norm_curtain_height", SP_DATTYPE::SP_DOUBLE    ,                "1.0",       "none",     true,         "",    "",    false,     "Normalized particle curtain height", "Particle curtain height starting from the bottom of the aperture normalized to the aperture height");
	recs.back().norm_curtain_width   .set("receiver."+sid+".norm_curtain_width", SP_DATTYPE::SP_DOUBLE    ,                "1.0",       "none",     true,         "",    "",    false,      "Normalized particle curtain width", "Particle curtain width normalized to the aperture width");
	recs.back().norm_heights_depths  .set("receiver."+sid+".norm_heights_depths", SP_DATTYPE::SP_MATRIX_T  ,           "0.5,0.8;",       "none",     true,         "",    "",    false,  "Normalized troughs heights and depths", "Normalized troughs heights and depths starting from the receiver entrance and working down");
	recs.back().panel_rotation       .set("receiver."+sid+".panel_rotation"  , SP_DATTYPE::SP_DOUBLE    ,                "0.0",        "deg",     true,         "",    "",     true,   "Receiver panel azimuthal orientation", "Azimuth angle between the normal vector to the primary 'north' panel and North");
	recs.back().peak_flux            .set("receiver."+sid+".peak_flux"       , SP_DATTYPE::SP_DOUBLE    ,             "1000.0",      "kW/m2",     true,         "",    "",    false,                    "Allowable peak flux", "Maximum allowable flux intensity on any portion of the receiver surface");
	recs.back().piping_loss_coef     .set("receiver."+sid+".piping_loss_coef", SP_DATTYPE::SP_DOUBLE    ,               "10.2",       "kW/m",     true,         "",    "",    false,       "Receiver piping loss coefficient", "Loss per meter of tower height");
	recs.back().piping_loss_const    .set("receiver."+sid+".piping_loss_const", SP_DATTYPE::SP_DOUBLE    ,                "0.0",         "kW",     true,         "",    "",    false,          "Receiver piping loss constant", "Constant thermal loss due to piping - doesn't scale with tower height");
	recs.back().power_fraction       .set("receiver."+sid+".power_fraction"  , SP_DATTYPE::SP_DOUBLE    ,                "1.0",       "none",     true,         "",    "",    false,          "Multi-receiver power fraction", "Target fraction of absorbed energy delivered by the heliostat field in configurations with multiple receivers");
	recs.back().rec_azimuth          .set("receiver."+sid+".rec_azimuth"     , SP_DATTYPE::SP_DOUBLE    ,                "0.0",        "deg",     true,         "",    "",    false,           "Receiver orientation azimuth", "Receiver azimuth orientation: 0 deg is north, positive clockwise");
	recs.back().rec_cav_apwfrac      .set("receiver."+sid+".rec_cav_apwfrac" , SP_DATTYPE::SP_DOUBLE    ,                "1.0",       "none",     true,         "",    "",     true,         "Cavity aperture width fraction", "Width of cavity aperture relative to maximum width at the aperture plane");
	recs.back().rec_cav_blip         .set("receiver."+sid+".rec_cav_blip"    , SP_DATTYPE::SP_DOUBLE    ,                "0.0",       "none",     true,         "",    "",     true,    "Cavity bottom lip fractional height", "Fraction of the total receiver height occupied by the bottom lip in a cavity geometry");
	recs.back().rec_cav_cdepth       .set("receiver."+sid+".rec_cav_cdepth"  , SP_DATTYPE::SP_DOUBLE    ,              "-0.25",       "none",     true,         "",    "",    false, "Cavity absorber centroid aperture offset", "Offset of centroid of cavity absorber surfaces from the aperture plane (fraction of cavity radius); positive yields greater receiver depth");
	recs.back().rec_cav_rad          .set("receiver."+sid+".rec_cav_rad"     , SP_DATTYPE::SP_DOUBLE    ,                "8.0",          "m",     true,         "",    "",    false,           "Cavity active surface radius", "Radius of the circle circumscribing all active absorber surfaces");
	recs.back().rec_cav_tlip         .set("receiver."+sid+".rec_cav_tlip"    , SP_DATTYPE::SP_DOUBLE    ,                "0.0",       "none",     true,         "",    "",     true,       "Cavity top lip fractional height", "Fraction of the total receiver height occupied by the top lip in a cavity geometry");
	recs.back().rec_diameter         .set("receiver."+sid+".rec_diameter"    , SP_DATTYPE::SP_DOUBLE    ,              "17.65",          "m",     true,         "",    "",    false,                      "Receiver diameter", "Receiver diameter for cylindrical receivers");
	recs.back().rec_elevation        .set("receiver."+sid+".rec_elevation"   , SP_DATTYPE::SP_DOUBLE    ,                "0.0",        "deg",     true,         "",    "",    false,         "Receiver orientation elevation", "Receiver elevation orientation: 0 deg to the horizon, negative rotating downward");
	recs.back().rec_height           .set("receiver."+sid+".rec_height"      , SP_DATTYPE::SP_DOUBLE    ,               "21.6",          "m",     true,         "",    "",    false,                        "Receiver height", "Height of the absorbing component (height of aperture for falling particle geometry)");
	recs.back().rec_name             .set("receiver."+sid+".rec_name"        , SP_DATTYPE::SP_STRING    ,         "Receiver 1",           "",    false,         "",    "",    false,                 "Receiver template name", "Receiver template name");
	recs.back().rec_offset_reference .set("receiver."+sid+".rec_offset_reference", SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "Tower=-1",    false,              "Receiver offset reference", "Receiver offset is relative to the position of the selected item. Options include tower or other receivers.");
	recs.back().rec_offset_x         .set("receiver."+sid+".rec_offset_x"    , SP_DATTYPE::SP_DOUBLE    ,                "0.0",          "m",     true,         "",    "",    false,   "Receiver positioning offset - X axis", "Offset of receiver center in the East(+)/West(-) direction from the reference object");
	recs.back().rec_offset_y         .set("receiver."+sid+".rec_offset_y"    , SP_DATTYPE::SP_DOUBLE    ,                "0.0",          "m",     true,         "",    "",    false,   "Receiver positioning offset - Y axis", "Offset of receiver center in the North(+)/South(-) direction from the reference object");
	recs.back().rec_offset_z         .set("receiver."+sid+".rec_offset_z"    , SP_DATTYPE::SP_DOUBLE    ,                "0.0",          "m",     true,         "",    "",    false,   "Receiver positioning offset - Z axis", "Offset of the receiver center in the vertical direction from the reference object, positive upwards");
	recs.back().rec_type             .set("receiver."+sid+".rec_type"        , SP_DATTYPE::SP_STRING    ,                  "0",       "none",    false,    "combo", "External cylindrical=0;Cavity=1;Flat plate=2;Falling particle=3",    false,                          "Receiver type", "Receiver geometrical configuration");
	recs.back().rec_width            .set("receiver."+sid+".rec_width"       , SP_DATTYPE::SP_DOUBLE    ,               "17.0",          "m",     true,         "",    "",    false,                         "Receiver width", "Receiver aperture width for flat plate and falling particle geometry ");
	recs.back().snout_depth          .set("receiver."+sid+".snout_depth"     , SP_DATTYPE::SP_DOUBLE    ,                "1.5",          "m",     true,         "",    "",    false,                            "SNOUT depth", "Distance from aperture window to SNOUT front plane");
	recs.back().snout_horiz_angle    .set("receiver."+sid+".snout_horiz_angle", SP_DATTYPE::SP_DOUBLE    ,              "120.0",        "deg",     true,         "",    "",    false,                 "Horizontal SNOUT angle", "SNOUT spanning angle defined in the aperture vertical midplane");
	recs.back().snout_vert_bot_angle .set("receiver."+sid+".snout_vert_bot_angle", SP_DATTYPE::SP_DOUBLE    ,               "20.0",        "deg",     true,         "",    "",    false,            "Vertical SNOUT bottom angle", "SNOUT bottom surface angle from aperture normal");
	recs.back().snout_vert_top_angle .set("receiver."+sid+".snout_vert_top_angle", SP_DATTYPE::SP_DOUBLE    ,               "20.0",        "deg",     true,         "",    "",    false,               "Vertical SNOUT top angle", "SNOUT top surface angle from aperture normal");
	recs.back().therm_loss_base      .set("receiver."+sid+".therm_loss_base" , SP_DATTYPE::SP_DOUBLE    ,               "30.0",      "kW/m2",     true,         "",    "",    false,     "Design point receiver thermal loss", "Thermal loss from the receiver at design-point conditions");
	recs.back().therm_loss_load      .set("receiver."+sid+".therm_loss_load" , SP_DATTYPE::SP_MATRIX_T  ,            "1,0,0,0",       "none",    false,         "",    "",    false,     "Load-based thermal loss adjustment", "Temperature-dependant thermal loss");
	recs.back().therm_loss_wind      .set("receiver."+sid+".therm_loss_wind" , SP_DATTYPE::SP_MATRIX_T  ,            "1,0,0,0",       "none",    false,         "",    "",    false,     "Wind-based thermal loss adjustment", "Wind speed-dependant thermal loss");
	recs.back().user_flux_profile    .set("receiver."+sid+".user_flux_profile", SP_DATTYPE::SP_MATRIX_T  , "1,1,1,1,1;1,1,1,1,1;1,1,1,1,1;1,1,1,1,1;1,1,1,1,1",       "none",    false,         "",    "",    false,                 "User flux profile data", "User flux profile data");
	recs.back().absorber_area        .setup("receiver."+sid+".absorber_area"   , SP_DATTYPE::SP_DOUBLE    ,                               "m2",    false,         "",    "",    false,                 "Receiver absorber area", "Effective area of the receiver absorber panels");
	recs.back().aperture_area        .setup("receiver."+sid+".aperture_area"   , SP_DATTYPE::SP_DOUBLE    ,                               "m2",    false,         "",    "",    false,                 "Receiver aperture area", "Area of the aperture available to heliostat aiming");
	recs.back().curtain_total_height .setup("receiver."+sid+".curtain_total_height", SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,          "Particle curtain total height", "Particle curtain total height");
	recs.back().max_curtain_width    .setup("receiver."+sid+".max_curtain_width", SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,         "Particle curtain maximum width", "Particle curtain maximum width");
	recs.back().n_user_flux_profile  .setup("receiver."+sid+".n_user_flux_profile", SP_DATTYPE::SP_MATRIX_T  ,                             "none",    false,         "",    "",    false,           "Normalized user flux profile", "Normalized user flux profile");
	recs.back().optical_height       .setup("receiver."+sid+".optical_height"  , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,                "Receiver optical height", "Calculated height of the centerline of the receiver above the plane of the heliostats");
	recs.back().piping_loss          .setup("receiver."+sid+".piping_loss"     , SP_DATTYPE::SP_DOUBLE    ,                               "MW",    false,         "",    "",    false,                   "Receiver piping loss", "Thermal loss from non-absorber receiver piping");
	recs.back().q_rec_des            .setup("receiver."+sid+".q_rec_des"       , SP_DATTYPE::SP_DOUBLE    ,                               "MW",    false,         "",    "",    false,             "Design-point thermal power", "Power produced by the receiver at design after thermal losses");
	recs.back().rec_aspect           .setup("receiver."+sid+".rec_aspect"      , SP_DATTYPE::SP_DOUBLE    ,                             "none",     true,         "",    "",    false,            "Receiver aspect ratio (H/W)", "Ratio of receiver height to width");
	recs.back().rec_cav_aph          .setup("receiver."+sid+".rec_cav_aph"     , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,                 "Cavity aperture height", "Calculated aperture height based on receiver height and lip height fractions");
	recs.back().rec_cav_apw          .setup("receiver."+sid+".rec_cav_apw"     , SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false,                  "Cavity aperture width", "Calculated aperture width based on cavity geometry and aperture width fraction");
	recs.back().rec_offset_x_global  .setup("receiver."+sid+".rec_offset_x_global", SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false, "Receiver global positioning offset - X axis", "Offset of receiver center in the East(+)/West(-) direction from the tower");
	recs.back().rec_offset_y_global  .setup("receiver."+sid+".rec_offset_y_global", SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false, "Receiver global positioning offset - Y axis", "Offset of receiver center in the North(+)/South(-) direction from the tower");
	recs.back().rec_offset_z_global  .setup("receiver."+sid+".rec_offset_z_global", SP_DATTYPE::SP_DOUBLE    ,                                "m",    false,         "",    "",    false, "Receiver global positioning offset - Z axis", "Offset of the receiver center in the vertical direction, positive upwards");
	recs.back().therm_eff            .setup("receiver."+sid+".therm_eff"       , SP_DATTYPE::SP_DOUBLE    ,                             "none",    false,         "",    "",    false, "Receiver calculated thermal efficiency", "Receiver calculated thermal efficiency");
	recs.back().therm_loss           .setup("receiver."+sid+".therm_loss"      , SP_DATTYPE::SP_DOUBLE    ,                               "MW",    false,         "",    "",    false,              "Design-point thermal loss", "Receiver thermal loss at design");

	recs.back().id.val = id;
	recs.back().addptrs( _varptrs );
}

void var_ambient::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	_local_varptrs["ambient.0.atm_coefs"] = &atm_coefs;
	_local_varptrs["ambient.0.atm_model"] = &atm_model;
	_local_varptrs["ambient.0.class_name"] = &class_name;
	_local_varptrs["ambient.0.del_h2o"] = &del_h2o;
	_local_varptrs["ambient.0.dni_layout"] = &dni_layout;
	_local_varptrs["ambient.0.dpres"] = &dpres;
	_local_varptrs["ambient.0.elevation"] = &elevation;
	_local_varptrs["ambient.0.insol_type"] = &insol_type;
	_local_varptrs["ambient.0.latitude"] = &latitude;
	_local_varptrs["ambient.0.loc_city"] = &loc_city;
	_local_varptrs["ambient.0.loc_state"] = &loc_state;
	_local_varptrs["ambient.0.longitude"] = &longitude;
	_local_varptrs["ambient.0.sun_csr"] = &sun_csr;
	_local_varptrs["ambient.0.sun_pos_map"] = &sun_pos_map;
	_local_varptrs["ambient.0.sun_rad_limit"] = &sun_rad_limit;
	_local_varptrs["ambient.0.sun_type"] = &sun_type;
	_local_varptrs["ambient.0.time_zone"] = &time_zone;
	_local_varptrs["ambient.0.user_sun"] = &user_sun;
	_local_varptrs["ambient.0.weather_file"] = &weather_file;
	_local_varptrs["ambient.0.wf_data"] = &wf_data;
	_local_varptrs["ambient.0.atm_atten_est"] = &atm_atten_est;
	_local_varptrs["ambient.0.sim_time_step"] = &sim_time_step;
	_local_varptrs["ambient.0.sun_csr_adj"] = &sun_csr_adj;

	for (unordered_map<std::string, spbase*>::iterator it = _local_varptrs.begin(); it != _local_varptrs.end(); it++)
		pmap[it->first] = it->second;
}


void var_financial::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	_local_varptrs["financial.0.class_name"] = &class_name;
	_local_varptrs["financial.0.contingency_rate"] = &contingency_rate;
	_local_varptrs["financial.0.fixed_cost"] = &fixed_cost;
	_local_varptrs["financial.0.heliostat_spec_cost"] = &heliostat_spec_cost;
	_local_varptrs["financial.0.is_pmt_factors"] = &is_pmt_factors;
	_local_varptrs["financial.0.land_spec_cost"] = &land_spec_cost;
	_local_varptrs["financial.0.pmt_factors"] = &pmt_factors;
	_local_varptrs["financial.0.rec_cost_exp"] = &rec_cost_exp;
	_local_varptrs["financial.0.rec_ref_area"] = &rec_ref_area;
	_local_varptrs["financial.0.rec_ref_cost"] = &rec_ref_cost;
	_local_varptrs["financial.0.sales_tax_frac"] = &sales_tax_frac;
	_local_varptrs["financial.0.sales_tax_rate"] = &sales_tax_rate;
	_local_varptrs["financial.0.site_spec_cost"] = &site_spec_cost;
	_local_varptrs["financial.0.tower_exp"] = &tower_exp;
	_local_varptrs["financial.0.tower_fixed_cost"] = &tower_fixed_cost;
	_local_varptrs["financial.0.weekday_sched"] = &weekday_sched;
	_local_varptrs["financial.0.weekend_sched"] = &weekend_sched;
	_local_varptrs["financial.0.wiring_user_spec"] = &wiring_user_spec;
	_local_varptrs["financial.0.contingency_cost"] = &contingency_cost;
	_local_varptrs["financial.0.heliostat_cost"] = &heliostat_cost;
	_local_varptrs["financial.0.land_cost"] = &land_cost;
	_local_varptrs["financial.0.pricing_array"] = &pricing_array;
	_local_varptrs["financial.0.rec_cost"] = &rec_cost;
	_local_varptrs["financial.0.sales_tax_cost"] = &sales_tax_cost;
	_local_varptrs["financial.0.schedule_array"] = &schedule_array;
	_local_varptrs["financial.0.site_cost"] = &site_cost;
	_local_varptrs["financial.0.total_direct_cost"] = &total_direct_cost;
	_local_varptrs["financial.0.total_indirect_cost"] = &total_indirect_cost;
	_local_varptrs["financial.0.total_installed_cost"] = &total_installed_cost;
	_local_varptrs["financial.0.tower_cost"] = &tower_cost;
	_local_varptrs["financial.0.wiring_cost"] = &wiring_cost;

	for (unordered_map<std::string, spbase*>::iterator it = _local_varptrs.begin(); it != _local_varptrs.end(); it++)
		pmap[it->first] = it->second;
}


void var_fluxsim::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	_local_varptrs["fluxsim.0.aim_method"] = &aim_method;
	_local_varptrs["fluxsim.0.class_name"] = &class_name;
	_local_varptrs["fluxsim.0.cloud_depth"] = &cloud_depth;
	_local_varptrs["fluxsim.0.cloud_loc_x"] = &cloud_loc_x;
	_local_varptrs["fluxsim.0.cloud_loc_y"] = &cloud_loc_y;
	_local_varptrs["fluxsim.0.cloud_opacity"] = &cloud_opacity;
	_local_varptrs["fluxsim.0.cloud_sep_depth"] = &cloud_sep_depth;
	_local_varptrs["fluxsim.0.cloud_sep_width"] = &cloud_sep_width;
	_local_varptrs["fluxsim.0.cloud_shape"] = &cloud_shape;
	_local_varptrs["fluxsim.0.cloud_skew"] = &cloud_skew;
	_local_varptrs["fluxsim.0.cloud_width"] = &cloud_width;
	_local_varptrs["fluxsim.0.flux_data"] = &flux_data;
	_local_varptrs["fluxsim.0.flux_day"] = &flux_day;
	_local_varptrs["fluxsim.0.flux_dist"] = &flux_dist;
	_local_varptrs["fluxsim.0.flux_dni"] = &flux_dni;
	_local_varptrs["fluxsim.0.flux_hour"] = &flux_hour;
	_local_varptrs["fluxsim.0.flux_model"] = &flux_model;
	_local_varptrs["fluxsim.0.flux_month"] = &flux_month;
	_local_varptrs["fluxsim.0.flux_solar_az_in"] = &flux_solar_az_in;
	_local_varptrs["fluxsim.0.flux_solar_el_in"] = &flux_solar_el_in;
	_local_varptrs["fluxsim.0.flux_time_type"] = &flux_time_type;
	_local_varptrs["fluxsim.0.is_autoscale"] = &is_autoscale;
	_local_varptrs["fluxsim.0.is_cloud_pattern"] = &is_cloud_pattern;
	_local_varptrs["fluxsim.0.is_cloud_symd"] = &is_cloud_symd;
	_local_varptrs["fluxsim.0.is_cloud_symw"] = &is_cloud_symw;
	_local_varptrs["fluxsim.0.is_cloudy"] = &is_cloudy;
	_local_varptrs["fluxsim.0.is_dynamic_group"] = &is_dynamic_group;
	_local_varptrs["fluxsim.0.is_load_raydata"] = &is_load_raydata;
	_local_varptrs["fluxsim.0.is_optical_err"] = &is_optical_err;
	_local_varptrs["fluxsim.0.is_save_raydata"] = &is_save_raydata;
	_local_varptrs["fluxsim.0.is_sunshape_err"] = &is_sunshape_err;
	_local_varptrs["fluxsim.0.max_rays"] = &max_rays;
	_local_varptrs["fluxsim.0.min_rays"] = &min_rays;
	_local_varptrs["fluxsim.0.multi_rec_aim_rand"] = &multi_rec_aim_rand;
	_local_varptrs["fluxsim.0.norm_dist_sigma"] = &norm_dist_sigma;
	_local_varptrs["fluxsim.0.plot_zmax"] = &plot_zmax;
	_local_varptrs["fluxsim.0.plot_zmin"] = &plot_zmin;
	_local_varptrs["fluxsim.0.raydata_file"] = &raydata_file;
	_local_varptrs["fluxsim.0.save_data"] = &save_data;
	_local_varptrs["fluxsim.0.save_data_loc"] = &save_data_loc;
	_local_varptrs["fluxsim.0.seed"] = &seed;
	_local_varptrs["fluxsim.0.sigma_limit_x"] = &sigma_limit_x;
	_local_varptrs["fluxsim.0.sigma_limit_y"] = &sigma_limit_y;
	_local_varptrs["fluxsim.0.x_res"] = &x_res;
	_local_varptrs["fluxsim.0.y_res"] = &y_res;
	_local_varptrs["fluxsim.0.flux_solar_az"] = &flux_solar_az;
	_local_varptrs["fluxsim.0.flux_solar_el"] = &flux_solar_el;

	for (unordered_map<std::string, spbase*>::iterator it = _local_varptrs.begin(); it != _local_varptrs.end(); it++)
		pmap[it->first] = it->second;
}


void var_heliostat::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	std::string sid = my_to_string(id.val);
	_local_varptrs["heliostat."+sid+".cant_day"] = &cant_day;
	_local_varptrs["heliostat."+sid+".cant_hour"] = &cant_hour;
	_local_varptrs["heliostat."+sid+".cant_method"] = &cant_method;
	_local_varptrs["heliostat."+sid+".cant_rad_scaled"] = &cant_rad_scaled;
	_local_varptrs["heliostat."+sid+".cant_vect_i"] = &cant_vect_i;
	_local_varptrs["heliostat."+sid+".cant_vect_j"] = &cant_vect_j;
	_local_varptrs["heliostat."+sid+".cant_vect_k"] = &cant_vect_k;
	_local_varptrs["heliostat."+sid+".cant_vect_scale"] = &cant_vect_scale;
	_local_varptrs["heliostat."+sid+".cbdata"] = &cbdata;
	_local_varptrs["heliostat."+sid+".class_name"] = &class_name;
	_local_varptrs["heliostat."+sid+".diameter"] = &diameter;
	_local_varptrs["heliostat."+sid+".err_azimuth"] = &err_azimuth;
	_local_varptrs["heliostat."+sid+".err_elevation"] = &err_elevation;
	_local_varptrs["heliostat."+sid+".err_reflect_x"] = &err_reflect_x;
	_local_varptrs["heliostat."+sid+".err_reflect_y"] = &err_reflect_y;
	_local_varptrs["heliostat."+sid+".err_surface_x"] = &err_surface_x;
	_local_varptrs["heliostat."+sid+".err_surface_y"] = &err_surface_y;
	_local_varptrs["heliostat."+sid+".focus_method"] = &focus_method;
	_local_varptrs["heliostat."+sid+".height"] = &height;
	_local_varptrs["heliostat."+sid+".helio_name"] = &helio_name;
	_local_varptrs["heliostat."+sid+".id"] = &id;
	_local_varptrs["heliostat."+sid+".is_cant_rad_scaled"] = &is_cant_rad_scaled;
	_local_varptrs["heliostat."+sid+".is_cant_vect_slant"] = &is_cant_vect_slant;
	_local_varptrs["heliostat."+sid+".is_enabled"] = &is_enabled;
	_local_varptrs["heliostat."+sid+".is_faceted"] = &is_faceted;
	_local_varptrs["heliostat."+sid+".is_focal_equal"] = &is_focal_equal;
	_local_varptrs["heliostat."+sid+".is_round"] = &is_round;
	_local_varptrs["heliostat."+sid+".is_xfocus"] = &is_xfocus;
	_local_varptrs["heliostat."+sid+".is_yfocus"] = &is_yfocus;
	_local_varptrs["heliostat."+sid+".n_cant_x"] = &n_cant_x;
	_local_varptrs["heliostat."+sid+".n_cant_y"] = &n_cant_y;
	_local_varptrs["heliostat."+sid+".reflect_ratio"] = &reflect_ratio;
	_local_varptrs["heliostat."+sid+".reflectivity"] = &reflectivity;
	_local_varptrs["heliostat."+sid+".rvel_max_x"] = &rvel_max_x;
	_local_varptrs["heliostat."+sid+".rvel_max_y"] = &rvel_max_y;
	_local_varptrs["heliostat."+sid+".soiling"] = &soiling;
	_local_varptrs["heliostat."+sid+".st_err_type"] = &st_err_type;
	_local_varptrs["heliostat."+sid+".temp_az_max"] = &temp_az_max;
	_local_varptrs["heliostat."+sid+".temp_az_min"] = &temp_az_min;
	_local_varptrs["heliostat."+sid+".temp_rad_max"] = &temp_rad_max;
	_local_varptrs["heliostat."+sid+".temp_rad_min"] = &temp_rad_min;
	_local_varptrs["heliostat."+sid+".template_order"] = &template_order;
	_local_varptrs["heliostat."+sid+".track_method"] = &track_method;
	_local_varptrs["heliostat."+sid+".track_period"] = &track_period;
	_local_varptrs["heliostat."+sid+".type"] = &type;
	_local_varptrs["heliostat."+sid+".width"] = &width;
	_local_varptrs["heliostat."+sid+".x_focal_length"] = &x_focal_length;
	_local_varptrs["heliostat."+sid+".x_gap"] = &x_gap;
	_local_varptrs["heliostat."+sid+".y_focal_length"] = &y_focal_length;
	_local_varptrs["heliostat."+sid+".y_gap"] = &y_gap;
	_local_varptrs["heliostat."+sid+".area"] = &area;
	_local_varptrs["heliostat."+sid+".cant_mag_i"] = &cant_mag_i;
	_local_varptrs["heliostat."+sid+".cant_mag_j"] = &cant_mag_j;
	_local_varptrs["heliostat."+sid+".cant_mag_k"] = &cant_mag_k;
	_local_varptrs["heliostat."+sid+".cant_norm_i"] = &cant_norm_i;
	_local_varptrs["heliostat."+sid+".cant_norm_j"] = &cant_norm_j;
	_local_varptrs["heliostat."+sid+".cant_norm_k"] = &cant_norm_k;
	_local_varptrs["heliostat."+sid+".cant_radius"] = &cant_radius;
	_local_varptrs["heliostat."+sid+".cant_sun_az"] = &cant_sun_az;
	_local_varptrs["heliostat."+sid+".cant_sun_el"] = &cant_sun_el;
	_local_varptrs["heliostat."+sid+".err_total"] = &err_total;
	_local_varptrs["heliostat."+sid+".r_collision"] = &r_collision;
	_local_varptrs["heliostat."+sid+".ref_total"] = &ref_total;

	for (unordered_map<std::string, spbase*>::iterator it = _local_varptrs.begin(); it != _local_varptrs.end(); it++)
		pmap[it->first] = it->second;
}


void var_land::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	_local_varptrs["land.0.class_name"] = &class_name;
	_local_varptrs["land.0.exclusions"] = &exclusions;
	_local_varptrs["land.0.import_tower_lat"] = &import_tower_lat;
	_local_varptrs["land.0.import_tower_lon"] = &import_tower_lon;
	_local_varptrs["land.0.import_tower_set"] = &import_tower_set;
	_local_varptrs["land.0.inclusions"] = &inclusions;
	_local_varptrs["land.0.is_bounds_array"] = &is_bounds_array;
	_local_varptrs["land.0.is_bounds_fixed"] = &is_bounds_fixed;
	_local_varptrs["land.0.is_bounds_scaled"] = &is_bounds_scaled;
	_local_varptrs["land.0.is_exclusions_relative"] = &is_exclusions_relative;
	_local_varptrs["land.0.land_const"] = &land_const;
	_local_varptrs["land.0.land_mult"] = &land_mult;
	_local_varptrs["land.0.max_fixed_rad"] = &max_fixed_rad;
	_local_varptrs["land.0.max_scaled_rad"] = &max_scaled_rad;
	_local_varptrs["land.0.min_fixed_rad"] = &min_fixed_rad;
	_local_varptrs["land.0.min_scaled_rad"] = &min_scaled_rad;
	_local_varptrs["land.0.tower_offset_x"] = &tower_offset_x;
	_local_varptrs["land.0.tower_offset_y"] = &tower_offset_y;
	_local_varptrs["land.0.bound_area"] = &bound_area;
	_local_varptrs["land.0.land_area"] = &land_area;
	_local_varptrs["land.0.radmax_m"] = &radmax_m;
	_local_varptrs["land.0.radmin_m"] = &radmin_m;

	for (unordered_map<std::string, spbase*>::iterator it = _local_varptrs.begin(); it != _local_varptrs.end(); it++)
		pmap[it->first] = it->second;
}


void var_optimize::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	_local_varptrs["optimize.0.algorithm"] = &algorithm;
	_local_varptrs["optimize.0.class_name"] = &class_name;
	_local_varptrs["optimize.0.converge_tol"] = &converge_tol;
	_local_varptrs["optimize.0.flux_penalty"] = &flux_penalty;
	_local_varptrs["optimize.0.is_log_to_file"] = &is_log_to_file;
	_local_varptrs["optimize.0.log_file_path"] = &log_file_path;
	_local_varptrs["optimize.0.max_desc_iter"] = &max_desc_iter;
	_local_varptrs["optimize.0.max_gs_iter"] = &max_gs_iter;
	_local_varptrs["optimize.0.max_iter"] = &max_iter;
	_local_varptrs["optimize.0.max_step"] = &max_step;
	_local_varptrs["optimize.0.multirec_opt_timeout"] = &multirec_opt_timeout;
	_local_varptrs["optimize.0.multirec_screen_mult"] = &multirec_screen_mult;
	_local_varptrs["optimize.0.power_penalty"] = &power_penalty;
	_local_varptrs["optimize.0.aspect_display"] = &aspect_display;
	_local_varptrs["optimize.0.gs_refine_ratio"] = &gs_refine_ratio;

	for (unordered_map<std::string, spbase*>::iterator it = _local_varptrs.begin(); it != _local_varptrs.end(); it++)
		pmap[it->first] = it->second;
}


void var_parametric::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	_local_varptrs["parametric.0.class_name"] = &class_name;
	_local_varptrs["parametric.0.eff_file_name"] = &eff_file_name;
	_local_varptrs["parametric.0.flux_file_name"] = &flux_file_name;
	_local_varptrs["parametric.0.fluxmap_format"] = &fluxmap_format;
	_local_varptrs["parametric.0.is_fluxmap_norm"] = &is_fluxmap_norm;
	_local_varptrs["parametric.0.par_save_field_img"] = &par_save_field_img;
	_local_varptrs["parametric.0.par_save_flux_dat"] = &par_save_flux_dat;
	_local_varptrs["parametric.0.par_save_flux_img"] = &par_save_flux_img;
	_local_varptrs["parametric.0.par_save_helio"] = &par_save_helio;
	_local_varptrs["parametric.0.par_save_summary"] = &par_save_summary;
	_local_varptrs["parametric.0.sam_grid_format"] = &sam_grid_format;
	_local_varptrs["parametric.0.sam_out_dir"] = &sam_out_dir;
	_local_varptrs["parametric.0.upar_save_field_img"] = &upar_save_field_img;
	_local_varptrs["parametric.0.upar_save_flux_dat"] = &upar_save_flux_dat;
	_local_varptrs["parametric.0.upar_save_flux_img"] = &upar_save_flux_img;
	_local_varptrs["parametric.0.upar_save_helio"] = &upar_save_helio;
	_local_varptrs["parametric.0.upar_save_summary"] = &upar_save_summary;
	_local_varptrs["parametric.0.user_par_values"] = &user_par_values;

	for (unordered_map<std::string, spbase*>::iterator it = _local_varptrs.begin(); it != _local_varptrs.end(); it++)
		pmap[it->first] = it->second;
}


void var_receiver::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	std::string sid = my_to_string(id.val);
	_local_varptrs["receiver."+sid+".absorptance"] = &absorptance;
	_local_varptrs["receiver."+sid+".accept_ang_type"] = &accept_ang_type;
	_local_varptrs["receiver."+sid+".accept_ang_x"] = &accept_ang_x;
	_local_varptrs["receiver."+sid+".accept_ang_y"] = &accept_ang_y;
	_local_varptrs["receiver."+sid+".aperture_type"] = &aperture_type;
	_local_varptrs["receiver."+sid+".cbdata"] = &cbdata;
	_local_varptrs["receiver."+sid+".class_name"] = &class_name;
	_local_varptrs["receiver."+sid+".curtain_radius"] = &curtain_radius;
	_local_varptrs["receiver."+sid+".curtain_type"] = &curtain_type;
	_local_varptrs["receiver."+sid+".flux_profile_type"] = &flux_profile_type;
	_local_varptrs["receiver."+sid+".id"] = &id;
	_local_varptrs["receiver."+sid+".is_aspect_opt"] = &is_aspect_opt;
	_local_varptrs["receiver."+sid+".is_enabled"] = &is_enabled;
	_local_varptrs["receiver."+sid+".is_open_geom"] = &is_open_geom;
	_local_varptrs["receiver."+sid+".is_polygon"] = &is_polygon;
	_local_varptrs["receiver."+sid+".is_snout"] = &is_snout;
	_local_varptrs["receiver."+sid+".map_color"] = &map_color;
	_local_varptrs["receiver."+sid+".max_curtain_depth"] = &max_curtain_depth;
	_local_varptrs["receiver."+sid+".n_panels"] = &n_panels;
	_local_varptrs["receiver."+sid+".norm_curtain_height"] = &norm_curtain_height;
	_local_varptrs["receiver."+sid+".norm_curtain_width"] = &norm_curtain_width;
	_local_varptrs["receiver."+sid+".norm_heights_depths"] = &norm_heights_depths;
	_local_varptrs["receiver."+sid+".panel_rotation"] = &panel_rotation;
	_local_varptrs["receiver."+sid+".peak_flux"] = &peak_flux;
	_local_varptrs["receiver."+sid+".piping_loss_coef"] = &piping_loss_coef;
	_local_varptrs["receiver."+sid+".piping_loss_const"] = &piping_loss_const;
	_local_varptrs["receiver."+sid+".power_fraction"] = &power_fraction;
	_local_varptrs["receiver."+sid+".rec_azimuth"] = &rec_azimuth;
	_local_varptrs["receiver."+sid+".rec_cav_apwfrac"] = &rec_cav_apwfrac;
	_local_varptrs["receiver."+sid+".rec_cav_blip"] = &rec_cav_blip;
	_local_varptrs["receiver."+sid+".rec_cav_cdepth"] = &rec_cav_cdepth;
	_local_varptrs["receiver."+sid+".rec_cav_rad"] = &rec_cav_rad;
	_local_varptrs["receiver."+sid+".rec_cav_tlip"] = &rec_cav_tlip;
	_local_varptrs["receiver."+sid+".rec_diameter"] = &rec_diameter;
	_local_varptrs["receiver."+sid+".rec_elevation"] = &rec_elevation;
	_local_varptrs["receiver."+sid+".rec_height"] = &rec_height;
	_local_varptrs["receiver."+sid+".rec_name"] = &rec_name;
	_local_varptrs["receiver."+sid+".rec_offset_reference"] = &rec_offset_reference;
	_local_varptrs["receiver."+sid+".rec_offset_x"] = &rec_offset_x;
	_local_varptrs["receiver."+sid+".rec_offset_y"] = &rec_offset_y;
	_local_varptrs["receiver."+sid+".rec_offset_z"] = &rec_offset_z;
	_local_varptrs["receiver."+sid+".rec_type"] = &rec_type;
	_local_varptrs["receiver."+sid+".rec_width"] = &rec_width;
	_local_varptrs["receiver."+sid+".snout_depth"] = &snout_depth;
	_local_varptrs["receiver."+sid+".snout_horiz_angle"] = &snout_horiz_angle;
	_local_varptrs["receiver."+sid+".snout_vert_bot_angle"] = &snout_vert_bot_angle;
	_local_varptrs["receiver."+sid+".snout_vert_top_angle"] = &snout_vert_top_angle;
	_local_varptrs["receiver."+sid+".therm_loss_base"] = &therm_loss_base;
	_local_varptrs["receiver."+sid+".therm_loss_load"] = &therm_loss_load;
	_local_varptrs["receiver."+sid+".therm_loss_wind"] = &therm_loss_wind;
	_local_varptrs["receiver."+sid+".user_flux_profile"] = &user_flux_profile;
	_local_varptrs["receiver."+sid+".absorber_area"] = &absorber_area;
	_local_varptrs["receiver."+sid+".aperture_area"] = &aperture_area;
	_local_varptrs["receiver."+sid+".curtain_total_height"] = &curtain_total_height;
	_local_varptrs["receiver."+sid+".max_curtain_width"] = &max_curtain_width;
	_local_varptrs["receiver."+sid+".n_user_flux_profile"] = &n_user_flux_profile;
	_local_varptrs["receiver."+sid+".optical_height"] = &optical_height;
	_local_varptrs["receiver."+sid+".piping_loss"] = &piping_loss;
	_local_varptrs["receiver."+sid+".q_rec_des"] = &q_rec_des;
	_local_varptrs["receiver."+sid+".rec_aspect"] = &rec_aspect;
	_local_varptrs["receiver."+sid+".rec_cav_aph"] = &rec_cav_aph;
	_local_varptrs["receiver."+sid+".rec_cav_apw"] = &rec_cav_apw;
	_local_varptrs["receiver."+sid+".rec_offset_x_global"] = &rec_offset_x_global;
	_local_varptrs["receiver."+sid+".rec_offset_y_global"] = &rec_offset_y_global;
	_local_varptrs["receiver."+sid+".rec_offset_z_global"] = &rec_offset_z_global;
	_local_varptrs["receiver."+sid+".therm_eff"] = &therm_eff;
	_local_varptrs["receiver."+sid+".therm_loss"] = &therm_loss;

	for (unordered_map<std::string, spbase*>::iterator it = _local_varptrs.begin(); it != _local_varptrs.end(); it++)
		pmap[it->first] = it->second;
}


void var_solarfield::addptrs(unordered_map<std::string, spbase*> &pmap)
{
	_local_varptrs["solarfield.0.accept_max"] = &accept_max;
	_local_varptrs["solarfield.0.accept_min"] = &accept_min;
	_local_varptrs["solarfield.0.az_spacing"] = &az_spacing;
	_local_varptrs["solarfield.0.class_name"] = &class_name;
	_local_varptrs["solarfield.0.des_sim_detail"] = &des_sim_detail;
	_local_varptrs["solarfield.0.des_sim_ndays"] = &des_sim_ndays;
	_local_varptrs["solarfield.0.des_sim_nhours"] = &des_sim_nhours;
	_local_varptrs["solarfield.0.dni_des"] = &dni_des;
	_local_varptrs["solarfield.0.hsort_method"] = &hsort_method;
	_local_varptrs["solarfield.0.interaction_limit"] = &interaction_limit;
	_local_varptrs["solarfield.0.is_multirec_powfrac"] = &is_multirec_powfrac;
	_local_varptrs["solarfield.0.is_opt_zoning"] = &is_opt_zoning;
	_local_varptrs["solarfield.0.is_prox_filter"] = &is_prox_filter;
	_local_varptrs["solarfield.0.is_sliprow_skipped"] = &is_sliprow_skipped;
	_local_varptrs["solarfield.0.is_tht_opt"] = &is_tht_opt;
	_local_varptrs["solarfield.0.layout_data"] = &layout_data;
	_local_varptrs["solarfield.0.layout_method"] = &layout_method;
	_local_varptrs["solarfield.0.max_zone_size_az"] = &max_zone_size_az;
	_local_varptrs["solarfield.0.max_zone_size_rad"] = &max_zone_size_rad;
	_local_varptrs["solarfield.0.min_zone_size_az"] = &min_zone_size_az;
	_local_varptrs["solarfield.0.min_zone_size_rad"] = &min_zone_size_rad;
	_local_varptrs["solarfield.0.prox_filter_frac"] = &prox_filter_frac;
	_local_varptrs["solarfield.0.q_des"] = &q_des;
	_local_varptrs["solarfield.0.rad_spacing_method"] = &rad_spacing_method;
	_local_varptrs["solarfield.0.row_spacing_x"] = &row_spacing_x;
	_local_varptrs["solarfield.0.row_spacing_y"] = &row_spacing_y;
	_local_varptrs["solarfield.0.shadow_height"] = &shadow_height;
	_local_varptrs["solarfield.0.shadow_width"] = &shadow_width;
	_local_varptrs["solarfield.0.slip_plane_blocking"] = &slip_plane_blocking;
	_local_varptrs["solarfield.0.spacing_reset"] = &spacing_reset;
	_local_varptrs["solarfield.0.sun_az_des_user"] = &sun_az_des_user;
	_local_varptrs["solarfield.0.sun_el_des_user"] = &sun_el_des_user;
	_local_varptrs["solarfield.0.sun_loc_des"] = &sun_loc_des;
	_local_varptrs["solarfield.0.temp_which"] = &temp_which;
	_local_varptrs["solarfield.0.template_rule"] = &template_rule;
	_local_varptrs["solarfield.0.tht"] = &tht;
	_local_varptrs["solarfield.0.trans_limit_fact"] = &trans_limit_fact;
	_local_varptrs["solarfield.0.version"] = &version;
	_local_varptrs["solarfield.0.xy_field_shape"] = &xy_field_shape;
	_local_varptrs["solarfield.0.xy_rect_aspect"] = &xy_rect_aspect;
	_local_varptrs["solarfield.0.zone_div_tol"] = &zone_div_tol;
	_local_varptrs["solarfield.0.rec_area"] = &rec_area;
	_local_varptrs["solarfield.0.sf_area"] = &sf_area;
	_local_varptrs["solarfield.0.sim_step_data"] = &sim_step_data;
	_local_varptrs["solarfield.0.sun_az_des"] = &sun_az_des;
	_local_varptrs["solarfield.0.sun_el_des"] = &sun_el_des;

	for (unordered_map<std::string, spbase*>::iterator it = _local_varptrs.begin(); it != _local_varptrs.end(); it++)
		pmap[it->first] = it->second;
}



void var_map::drop_receiver(int id)
{
    //find the receiver in the list
    int id_ind=-1;
    for( int i=0; i<(int)recs.size(); i++)
    {
        if( recs.at(i).id.val == id )
        {
            id_ind = i;
            break;
        }
    }
    if( id_ind < 0 )
        throw spexception("Attempting to remove a receiver ID that doesn't exist!");

    //remove var ptrs
    std::string pat = "receiver.";

    unordered_map<std::string, spbase*>::iterator it = _varptrs.begin();
    while( it != _varptrs.end() )
    {
        if( it->first.find( pat ) != std::string::npos )
        {
            it = _varptrs.erase( it );
        }
        else
        {
            it++;
        }
    }
    
    //remove the variable structure
    recs.erase( recs.begin() + id_ind );

    //add back all receiver pointers
    for(int i=0; i<(int)recs.size(); i++)
    {
        recs.at(i).addptrs(_varptrs);
    }    
}

void var_map::drop_heliostat(int id)
{
    //find the heliostat in the list
    int id_ind=-1;
    for( int i=0; i<(int)hels.size(); i++)
    {
        if( hels.at(i).id.val == id )
        {
            id_ind = i;
            break;
        }
    }
    if( id_ind < 0 )
        throw spexception("Attempting to remove a heliostat ID that doesn't exist!");

    //remove var ptrs
    std::string pat = "heliostat.";

    unordered_map<std::string, spbase*>::iterator it = _varptrs.begin();
    while( it != _varptrs.end() )
    {
        if( it->first.find( pat ) != std::string::npos )
        {
            it = _varptrs.erase( it );
        }
        else
        {
            it++;
        }
    }
    
    //remove the variable structure
    hels.erase( hels.begin() + id_ind );

    //add back all heliostat pointers
    for(int i=0; i<(int)hels.size(); i++)
    {
        hels.at(i).addptrs(_varptrs);
    }
}
